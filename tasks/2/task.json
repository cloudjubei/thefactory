{
  "id": 2,
  "status": "+",
  "title": "Agent tools and scripts",
  "description": "",
  "features": [
    {
      "id": "2.1",
      "status": "+",
      "title": "Git manager",
      "description": "implement the git manager scripts",
      "context": [
        "scripts/git_manager.py"
      ],
      "acceptance": [
        "The file 'scripts/git_manager.py' exists.",
        "A class 'GitManager' is defined in 'scripts/git_manager.py'.",
        "The 'GitManager' class has an '__init__' method with a required 'repo_path' parameter.",
        "The 'GitManager' class has a 'clone' method with required 'url' and 'path' parameters.",
        "The 'GitManager' class has an 'add' method with an optional 'files' parameter.",
        "The 'GitManager' class has a 'commit' method with a required 'message' parameter.",
        "The 'GitManager' class has a 'push' method with an optional 'branch' parameter.",
        "The 'GitManager' class has a 'pull' method with an optional 'branch' parameter."
      ],
      "plan": "Detailed Step-by-Step Implementation Plan for Git Manager Scripts (Feature ID: 2.1):\n\n1. **Define Scope and Requirements**: Identify key Git operations needed for the manager scripts. Based on typical use cases for an agent tool, include: initializing a repo, cloning, adding files, committing changes, pushing to remote, pulling updates, branching, merging, and status checking. Consider error handling, authentication (e.g., via tokens), and integration with agent workflows. Research any project-specific needs (e.g., if this is for code generation agents).\n\n2. **Choose Technology Stack**: Opt for Python as the implementation language for portability and ease of integration with other agent tools. Use the 'subprocess' module to run Git commands securely. Alternatively, use a library like GitPython for higher-level abstractions to reduce subprocess risks. Ensure scripts are modular and can be called as functions.\n\n3. **Design the Script Structure**: Create a main module (e.g., git_manager.py) with a class or functions for each operation. Include logging (using Python's logging module) for debugging and output. Define input parameters (e.g., repo_path, commit_message, remote_url) and return values (e.g., success status, output messages).\n\n4. **Implement Core Functions**:\n   - init_repo(path): Initialize a new Git repo at the given path.\n   - clone_repo(url, path): Clone a repo from URL to local path.\n   - add_files(path, files): Stage files or all changes.\n   - commit_changes(path, message): Commit with a message.\n   - push_changes(path, branch): Push to remote branch.\n   - pull_updates(path, branch): Pull from remote.\n   - create_branch(path, branch_name): Create and checkout a new branch.\n   - merge_branch(path, branch_name): Merge a branch into current.\n   - get_status(path): Retrieve repo status.\n   Handle authentication (e.g., set Git config for user/email, handle SSH/HTTPS).\n\n5. **Add Error Handling and Validation**: Implement try-except blocks for subprocess errors. Validate inputs (e.g., check if path exists, if Git is installed). Provide meaningful error messages and optional verbose mode.\n\n6. **Write Unit Tests**: Use pytest to create tests for each function. Mock subprocess calls if using GitPython isn't feasible. Test scenarios: successful operations, failures (e.g., no internet for push), edge cases (e.g., empty commit).\n\n7. **Documentation and Usage Examples**: Add docstrings to functions. Create a README.md with examples of how to use the scripts in an agent context (e.g., integrating with other tools).\n\n8. **Integration and Review**: Ensure scripts can be imported and used in the parent task (Agent tools and scripts, ID: 2). Perform code review for security (e.g., avoid shell injection) and efficiency.\n\n9. **Final Testing and Deployment Prep**: Run end-to-end tests in a sample repo. Prepare for packaging (e.g., as a Python package) if needed for the project."
    },
    {
      "id": "2.2",
      "status": "+",
      "title": "Task Utility Tooling",
      "description": "Provide and maintain utility functions for programmatic interaction with task files in `scripts/task_utils.py`.",
      "context": [
        "docs/tasks/task_format.py",
        "docs/AGENT_PLANNER.md",
        "docs/AGENT_TESTER.md",
        "docs/AGENT_DEVELOPER.md",
        "docs/AGENT_CONTEXTER.md",
        "docs/FILE_ORGANISATION.md",
        "scripts/task_utils.py"
      ],
      "acceptance": [
        "The file `scripts/task_utils.py` exists.",
        "`scripts/task_utils.py` imports the Task and Feature schemas from `docs/tasks/task_format.py`.",
        "Functions in `scripts/task_utils.py` that modify files accept a `git_manager: GitManager` parameter, imported from `scripts/git_manager.py`.",
        "`scripts/task_utils.py` defines the following functions from AGENT_PLANNER.md: update_feature_plan(task_id: int, feature_id: str, plan: str), create_feature(task_id: int, feature: Feature), finish_feature(task_id: int, feature_id: str, git_manager: GitManager), block_feature(task_id: int, feature_id: str, reason: str).",
        "`scripts/task_utils.py` defines the following functions from AGENT_TESTER.md: update_acceptance_criteria(task_id: int, feature_id: str, criteria: list[str]), update_test(task_id: int, feature_id: str, test: str), run_test(task_id: int, feature_id: str) -> str.",
        "`scripts/task_utils.py` defines the following functions from AGENT_DEVELOPER.md: write_file(filename: str, content: str), get_context(files: list[str]) -> list[str].",
        "`scripts/task_utils.py` defines the following functions from AGENT_CONTEXTER.md: get_context(files: list[str]) -> list[str], update_feature_context(task_id: int, feature_id: str, context: list[str])->Feature",
        "All functions respect the file format in `docs/FILE_ORGANISATION.md`, e.g., reading/writing to `tasks/{id}/task.json` using the Task schema, and placing tests in `tasks/{id}/tests/test_{id}_{feature_id}.py`."
      ],
      "dependencies": [
        "2.1"
      ],
      "plan": "Step-by-step implementation plan for Feature 2.2: Task Utility Tooling\n\n1. Verify or create the 'scripts' directory in the project root to house the utility script.\n\n2. Create a new Python file named 'task_utils.py' inside the 'scripts' directory if it does not already exist.\n\n3. At the top of 'task_utils.py', import necessary modules: import json, import os.\n\n4. Define a constant for the task storage directory, e.g., TASK_DIR = os.path.join(os.path.dirname(__file__), '../tasks') (adjust path as needed to point to a 'tasks' directory).\n\n5. Implement the 'load_task' function:\n   - def load_task(task_id: str) -> dict:\n     - Construct file_path = os.path.join(TASK_DIR, f'{task_id}.json')\n     - Check if os.path.exists(file_path); if not, raise ValueError(f'Task {task_id} not found')\n     - Use with open(file_path, 'r') as f: return json.load(f)\n   - Add docstring: \"\"\"Loads a task from a JSON file by task_id. Returns task data as dict.\"\"\"\n\n6. Implement the 'save_task' function:\n   - def save_task(task_id: str, task_data: dict) -> None:\n     - Construct file_path = os.path.join(TASK_DIR, f'{task_id}.json')\n     - Ensure the directory exists: os.makedirs(TASK_DIR, exist_ok=True)\n     - Use with open(file_path, 'w') as f: json.dump(task_data, f, indent=4)\n   - Add docstring: \"\"\"Saves task data to a JSON file by task_id.\"\"\"\n\n7. Implement the 'update_task' function:\n   - def update_task(task_id: str, updates: dict) -> None:\n     - task = load_task(task_id)\n     - task.update(updates)\n     - save_task(task_id, task)\n   - Add docstring: \"\"\"Updates an existing task with new data and saves it.\"\"\"\n\n8. Implement the 'list_tasks' function:\n   - def list_tasks() -> list:\n     - if not os.path.exists(TASK_DIR): return []\n     - return [f.split('.')[0] for f in os.listdir(TASK_DIR) if f.endswith('.json')]\n   - Add docstring: \"\"\"Returns a list of all task_ids from the tasks directory.\"\"\"\n\n9. Implement the 'delete_task' function for completeness:\n   - def delete_task(task_id: str) -> None:\n     - file_path = os.path.join(TASK_DIR, f'{task_id}.json')\n     - if os.path.exists(file_path): os.remove(file_path)\n     - else: raise ValueError(f'Task {task_id} not found')\n   - Add docstring: \"\"\"Deletes a task file by task_id.\"\"\"\n\n10. Add error handling: Use try-except blocks for file operations to handle IOErrors or JSON decode errors.\n\n11. Add module-level docstring explaining the purpose of the utility script.\n\n12. Ensure all functions are testable and maintainable; consider adding type hints and comments.\n\nThis plan provides core utilities for interacting with task files. Future maintenance can add more functions as needed."
    },
    {
      "id": "2.3",
      "status": "+",
      "title": "Orchestrator script",
      "description": "Implement the local orchestrator script and setup, fully compliant with all the spec. It allows running an LLM agent to have conversations back and forth with tool calls.",
      "context": [
        "docs/AGENT_COMMUNICATION_PROTOCOL.md",
        "docs/agent_response_example.json",
        "scripts/git_manager.py",
        "scripts/tools_utils.py",
        "scripts/run_local_agent.py"
      ],
      "acceptance": [
        "scripts/run_local_agent.py exists and implements the orchestrator script.",
        "It abides to docs/AGENT_COMMUNICATION_PROTOCOL.md and implements the protocol format shown in docs/agent_response_example.json",
        "It directly uses a reference to GitManager from scripts/git_manager.py to perform git operations",
        "It directly uses scripts/tools_utils.py to call all appropriate tools",
        "The script has CLI options --mode {mode_type} where mode_type is either single (running just once) or continuous (running until there are no more tasks to work on)",
        "The script has the CLI required argument --task {task_id} to run specific tasks via prompt construction referencing tasks/{task_id}/task.json",
        "The script has the CLI required argument --agent {agent_type} where agent_type is one of the following: planner, tester, or developer.",
        "The script has a function to gather context for each agent type in a clean way",
        "The script has a function to gather all available tools for each agent type in a clean way",
        "The script passes all the relevant data, and especially context and tools available, to the agent type to start a multi-way conversation that will result in tool calls",
        "The conversation continues for a given task in continuous mode until the agent decides to finish calling the finish tool.",
        "The conversation continues for a given task in single mode until the agent decides to finish a feature calling the finish_feature tool."
      ],
      "dependencies": [
        "2.1",
        "2.2"
      ],
      "plan": "Step-by-step implementation plan for Orchestrator script (ID: 2.3):\n\n1. **Review and Understand Specifications**: Thoroughly review the provided spec for the orchestrator script, including requirements for LLM integration, tool calling format, conversation handling, and any compliance standards (e.g., message formats, error handling). Identify key components like supported tools, LLM model, and conversation persistence.\n\n2. **Set Up Development Environment**: Install required dependencies such as Python 3.10+, libraries like 'openai' for LLM access, 'langchain' or similar for agent orchestration (if specified), and any tool-specific packages. Create a virtual environment and configure API keys for local LLM if needed (e.g., for models like GPT-4).\n\n3. **Design Script Architecture**: Outline the script structure, including imports, configuration (e.g., LLM endpoint, tool definitions), a main orchestrator class or function, and a conversation history list to maintain state.\n\n4. **Implement LLM Integration**: Set up the LLM caller function that sends messages to the model, including system prompt, user messages, and available tools in the required format (e.g., JSON schema for tools).\n\n5. **Implement Tool Handling**: Define a tool registry or dictionary mapping tool names to functions. Create a parser for LLM responses to detect tool calls (e.g., if response has 'tool_calls' field). Implement execution logic to call the tools with provided arguments and capture outputs.\n\n6. **Build Conversation Loop**: Create a loop that:\n   - Prompts for user input.\n   - Appends input to message history.\n   - Calls the LLM with history and tools.\n   - If tool calls are present, execute them sequentially, append tool responses to history, and re-call LLM.\n   - If no tool calls, output the LLM response and continue the loop for back-and-forth interaction.\n   - Add a stopping condition (e.g., user types 'exit' or LLM signals end).\n\n7. **Ensure Spec Compliance**: Validate that the script adheres to all spec details, such as message formats, tool call schemas, handling parallel tool calls if supported, and local execution without external dependencies unless specified.\n\n8. **Add Error Handling and Logging**: Implement try-catch blocks for LLM calls, tool executions, and input handling. Add logging for conversation steps, errors, and tool outputs to aid debugging.\n\n9. **Testing and Validation**: Write unit tests for individual components (e.g., tool parser, LLM caller). Perform integration tests with sample conversations involving multiple tool calls and responses. Verify back-and-forth functionality and spec compliance.\n\n10. **Documentation and Cleanup**: Add inline comments, a README section for the script, usage instructions, and ensure the code is clean and modular for future extensions."
    },
    {
      "id": "2.4",
      "status": "+",
      "title": "Dependency specification",
      "description": "Create `requirements.txt` listing all external libraries used by `scripts/run_local_agent.py`, `scripts/git_manager.py, `scripts/task_utils.py",
      "plan": "Scan `scripts/run_local_agent.py` and list all non-standard library imports.\nScan `scripts/git_manager.py` and list all non-standard library imports.\nScan `scripts/task_utils.py` and list all non-standard library imports.\nCompile a single, unique list of all external dependencies identified in the previous steps.\nCreate a new file named `requirements.txt` in the project's root directory.\nAdd each unique dependency from the compiled list to `requirements.txt`, with each library on a new line.",
      "acceptance": [
        "`requirements.txt` exists in the project root.",
        "`requirements.txt` includes 'litellm'.",
        "`requirements.txt` includes 'python-dotenv'."
      ],
      "dependencies": [
        "2.1",
        "2.2",
        "2.3"
      ]
    },
    {
      "id": "2.5",
      "status": "+",
      "title": "Environment variables template",
      "description": "Provide `.env.example` containing placeholders for required API keys and settings.",
      "plan": "1. Create the `.env.example` file in the project root. 2. Add placeholder variables for API keys needed by `litellm` (e.g., `OPENAI_API_KEY=your_key_here`). 3. Include comments to explain each variable's purpose.",
      "acceptance": [
        "A file named `.env.example` exists in the project root.",
        "The file contains placeholders for required environment variables (e.g., VARIABLE=).",
        "Each environment variable is documented with a comment immediately preceding it, explaining its purpose.",
        "The file includes at least one such documented variable."
      ],
      "dependencies": [
        "2.1"
      ]
    },
    {
      "id": "2.6",
      "status": "+",
      "title": "Local setup guide",
      "description": "Author `docs/LOCAL_SETUP.md` with setup and execution instructions.",
      "acceptance": [
        "The file `docs/LOCAL_SETUP.md` exists.",
        "The file contains Markdown content with sections including 'Prerequisites', 'Installation', and 'Running' or 'Execution'.",
        "The instructions provide accurate steps for local setup and execution (manual verification may be needed for full accuracy)."
      ],
      "dependencies": [
        "2.3",
        "2.4",
        "2.5"
      ],
      "plan": "Step-by-step implementation plan for feature 2.6:\n1. Review the overall project structure (using available context or assumptions about agent tools and scripts) to identify key components like dependencies, main scripts, and any required configurations.\n2. Create the 'docs' directory in the project root if it does not already exist.\n3. Outline the structure of LOCAL_SETUP.md: Include sections such as Introduction, Prerequisites, Installation Steps, Configuration, Running the Project, Troubleshooting, and Additional Notes.\n4. Write the Introduction: Explain the purpose of the guide and what the project does.\n5. List Prerequisites: Specify required software (e.g., Python 3.8+, Git, virtual environment tools) and hardware.\n6. Detail Installation Steps: Include cloning the repository, creating a virtual environment, and installing dependencies via 'pip install -r requirements.txt' (assuming such a file exists or will be created in prior features).\n7. Describe Configuration: Cover setting up environment variables, API keys for agent tools, or any local databases.\n8. Provide Execution Instructions: Explain how to run the main agent scripts, command-line examples, and expected output.\n9. Add Troubleshooting: Common issues like dependency conflicts, permission errors, or API key problems, with solutions.\n10. Ensure the guide is clear, uses Markdown formatting (headings, lists, code blocks), and is beginner-friendly.\n11. Write and save the content to 'docs/LOCAL_SETUP.md'."
    }
  ]
}