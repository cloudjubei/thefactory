{
  "id": 2,
  "status": "-",
  "title": "Agent tools and scripts",
  "description": "",
  "features": [
    {
      "id": "2.1",
      "status": "+",
      "title": "Git manager",
      "description": "implement the git manager scripts",
      "context": [
        "scripts/git_manager.py"
      ],
      "acceptance": [
        "`scripts/git_manager.py` exists",
        "inside the script a class `GitManager` is implemented with all the necessary methods to interact with git repositories"
      ],
      "plan": "Detailed Step-by-Step Implementation Plan for Git Manager Scripts (Feature ID: 2.1):\n\n1. **Define Scope and Requirements**: Identify key Git operations needed for the manager scripts. Based on typical use cases for an agent tool, include: initializing a repo, cloning, adding files, committing changes, pushing to remote, pulling updates, branching, merging, and status checking. Consider error handling, authentication (e.g., via tokens), and integration with agent workflows. Research any project-specific needs (e.g., if this is for code generation agents).\n\n2. **Choose Technology Stack**: Opt for Python as the implementation language for portability and ease of integration with other agent tools. Use the 'subprocess' module to run Git commands securely. Alternatively, use a library like GitPython for higher-level abstractions to reduce subprocess risks. Ensure scripts are modular and can be called as functions.\n\n3. **Design the Script Structure**: Create a main module (e.g., git_manager.py) with a class or functions for each operation. Include logging (using Python's logging module) for debugging and output. Define input parameters (e.g., repo_path, commit_message, remote_url) and return values (e.g., success status, output messages).\n\n4. **Implement Core Functions**:\n   - init_repo(path): Initialize a new Git repo at the given path.\n   - clone_repo(url, path): Clone a repo from URL to local path.\n   - add_files(path, files): Stage files or all changes.\n   - commit_changes(path, message): Commit with a message.\n   - push_changes(path, branch): Push to remote branch.\n   - pull_updates(path, branch): Pull from remote.\n   - create_branch(path, branch_name): Create and checkout a new branch.\n   - merge_branch(path, branch_name): Merge a branch into current.\n   - get_status(path): Retrieve repo status.\n   Handle authentication (e.g., set Git config for user/email, handle SSH/HTTPS).\n\n5. **Add Error Handling and Validation**: Implement try-except blocks for subprocess errors. Validate inputs (e.g., check if path exists, if Git is installed). Provide meaningful error messages and optional verbose mode.\n\n6. **Write Unit Tests**: Use pytest to create tests for each function. Mock subprocess calls if using GitPython isn't feasible. Test scenarios: successful operations, failures (e.g., no internet for push), edge cases (e.g., empty commit).\n\n7. **Documentation and Usage Examples**: Add docstrings to functions. Create a README.md with examples of how to use the scripts in an agent context (e.g., integrating with other tools).\n\n8. **Integration and Review**: Ensure scripts can be imported and used in the parent task (Agent tools and scripts, ID: 2). Perform code review for security (e.g., avoid shell injection) and efficiency.\n\n9. **Final Testing and Deployment Prep**: Run end-to-end tests in a sample repo. Prepare for packaging (e.g., as a Python package) if needed for the project."
    },
    {
      "id": "2.2",
      "status": "+",
      "title": "Task Utility Tooling",
      "description": "Provide and maintain utility functions for programmatic interaction with task files in `scripts/task_utils.py`.",
      "context": [
        "docs/tasks/task_format.py",
        "docs/AGENT_PLANNER.md",
        "docs/AGENT_TESTER.md",
        "docs/AGENT_DEVELOPER.md",
        "docs/FILE_ORGANISATION.md",
        "scripts/task_utils.py"
      ],
      "acceptance": [
        "`scripts/task_utils.py` exists.",
        "it directly references the interface schema from `task_format.py`",
        "it directly uses a reference to `GitManager` from `scripts/git_manager.py` inside function parameters whenever necessary",
        "it has all the tools specified in `AGENT_PLANNER.md`",
        "it has all the tools specified in `AGENT_TESTER.md`",
        "it has all the tools specified in `AGENT_DEVELOPER.md`",
        "all tools respect the file format defined in `docs/FILE_ORGANISATION.md`"
      ],
      "dependencies": [
        "2.1"
      ],
      "plan": "Step-by-step implementation plan for Feature 2.2: Task Utility Tooling\n\n1. Verify or create the 'scripts' directory in the project root to house the utility script.\n\n2. Create a new Python file named 'task_utils.py' inside the 'scripts' directory if it does not already exist.\n\n3. At the top of 'task_utils.py', import necessary modules: import json, import os.\n\n4. Define a constant for the task storage directory, e.g., TASK_DIR = os.path.join(os.path.dirname(__file__), '../tasks') (adjust path as needed to point to a 'tasks' directory).\n\n5. Implement the 'load_task' function:\n   - def load_task(task_id: str) -> dict:\n     - Construct file_path = os.path.join(TASK_DIR, f'{task_id}.json')\n     - Check if os.path.exists(file_path); if not, raise ValueError(f'Task {task_id} not found')\n     - Use with open(file_path, 'r') as f: return json.load(f)\n   - Add docstring: \"\"\"Loads a task from a JSON file by task_id. Returns task data as dict.\"\"\"\n\n6. Implement the 'save_task' function:\n   - def save_task(task_id: str, task_data: dict) -> None:\n     - Construct file_path = os.path.join(TASK_DIR, f'{task_id}.json')\n     - Ensure the directory exists: os.makedirs(TASK_DIR, exist_ok=True)\n     - Use with open(file_path, 'w') as f: json.dump(task_data, f, indent=4)\n   - Add docstring: \"\"\"Saves task data to a JSON file by task_id.\"\"\"\n\n7. Implement the 'update_task' function:\n   - def update_task(task_id: str, updates: dict) -> None:\n     - task = load_task(task_id)\n     - task.update(updates)\n     - save_task(task_id, task)\n   - Add docstring: \"\"\"Updates an existing task with new data and saves it.\"\"\"\n\n8. Implement the 'list_tasks' function:\n   - def list_tasks() -> list:\n     - if not os.path.exists(TASK_DIR): return []\n     - return [f.split('.')[0] for f in os.listdir(TASK_DIR) if f.endswith('.json')]\n   - Add docstring: \"\"\"Returns a list of all task_ids from the tasks directory.\"\"\"\n\n9. Implement the 'delete_task' function for completeness:\n   - def delete_task(task_id: str) -> None:\n     - file_path = os.path.join(TASK_DIR, f'{task_id}.json')\n     - if os.path.exists(file_path): os.remove(file_path)\n     - else: raise ValueError(f'Task {task_id} not found')\n   - Add docstring: \"\"\"Deletes a task file by task_id.\"\"\"\n\n10. Add error handling: Use try-except blocks for file operations to handle IOErrors or JSON decode errors.\n\n11. Add module-level docstring explaining the purpose of the utility script.\n\n12. Ensure all functions are testable and maintainable; consider adding type hints and comments.\n\nThis plan provides core utilities for interacting with task files. Future maintenance can add more functions as needed."
    },
    {
      "id": "2.3",
      "status": "+",
      "title": "Orchestrator script",
      "description": "Implement the local orchestrator script and setup, fully compliant with all the spec. It allows running an LLM agent to have conversations back and forth with tool calls.",
      "context": [
        "docs/AGENT_COMMUNICATION_PROTOCOL.md",
        "docs/agent_response_example.json",
        "scripts/git_manager.py",
        "scripts/tools_utils.py",
        "scripts/run_local_agent.py"
      ],
      "acceptance": [
        "`scripts/run_local_agent.py` exists and implements the orchestrator script.",
        "it abides to `docs/AGENT_COMMUNICATION_PROTOCOL.md` and implements the protocol format shown in `docs/agent_response_example.json`",
        "it directly uses a reference to `GitManager` from `scripts/git_manager.py` to perform git operations",
        "it directly uses `scripts/tools_utils.py` to call all appropriate tools",
        "The script has CLI options `--mode {mode_type}` where `mode_type` is either `single` (running just once) or `continuous` (running until there are no more tasks to work on)",
        "The script has the CLI required argument `--task {task_id}` and the optional one `--feature {feature_id}` to run specific tasks/features via prompt construction referencing `tasks/{task_id}/task.json`.",
        "The script has the CLI required argument `--agent {agent_type}` where `agent_type` is one of the following: `planner`, `tester`, or `developer`.",
        "The script has a function to gather context for each agent type in a clean way",
        "The script has a function to gather all available tools for each agent type in a clean way",
        "The script passes all the relevant data, and especially context and tools available, to the agent type to start a multi-way conversation that will result in tool calls",
        "The conversation continues for a given task in continuous mode until the agent decides to finish calling the `finish` tool.",
        "The conversation continues for a given task in single mode until the agent decides to finish a feature calling the `finish_feature` tool."
      ],
      "dependencies": [
        "2.1",
        "2.2"
      ],
      "plan": "Step-by-step implementation plan for Orchestrator script (ID: 2.3):\n\n1. **Review and Understand Specifications**: Thoroughly review the provided spec for the orchestrator script, including requirements for LLM integration, tool calling format, conversation handling, and any compliance standards (e.g., message formats, error handling). Identify key components like supported tools, LLM model, and conversation persistence.\n\n2. **Set Up Development Environment**: Install required dependencies such as Python 3.10+, libraries like 'openai' for LLM access, 'langchain' or similar for agent orchestration (if specified), and any tool-specific packages. Create a virtual environment and configure API keys for local LLM if needed (e.g., for models like GPT-4).\n\n3. **Design Script Architecture**: Outline the script structure, including imports, configuration (e.g., LLM endpoint, tool definitions), a main orchestrator class or function, and a conversation history list to maintain state.\n\n4. **Implement LLM Integration**: Set up the LLM caller function that sends messages to the model, including system prompt, user messages, and available tools in the required format (e.g., JSON schema for tools).\n\n5. **Implement Tool Handling**: Define a tool registry or dictionary mapping tool names to functions. Create a parser for LLM responses to detect tool calls (e.g., if response has 'tool_calls' field). Implement execution logic to call the tools with provided arguments and capture outputs.\n\n6. **Build Conversation Loop**: Create a loop that:\n   - Prompts for user input.\n   - Appends input to message history.\n   - Calls the LLM with history and tools.\n   - If tool calls are present, execute them sequentially, append tool responses to history, and re-call LLM.\n   - If no tool calls, output the LLM response and continue the loop for back-and-forth interaction.\n   - Add a stopping condition (e.g., user types 'exit' or LLM signals end).\n\n7. **Ensure Spec Compliance**: Validate that the script adheres to all spec details, such as message formats, tool call schemas, handling parallel tool calls if supported, and local execution without external dependencies unless specified.\n\n8. **Add Error Handling and Logging**: Implement try-catch blocks for LLM calls, tool executions, and input handling. Add logging for conversation steps, errors, and tool outputs to aid debugging.\n\n9. **Testing and Validation**: Write unit tests for individual components (e.g., tool parser, LLM caller). Perform integration tests with sample conversations involving multiple tool calls and responses. Verify back-and-forth functionality and spec compliance.\n\n10. **Documentation and Cleanup**: Add inline comments, a README section for the script, usage instructions, and ensure the code is clean and modular for future extensions."
    },
    {
      "id": "2.4",
      "status": "+",
      "title": "Dependency specification",
      "description": "Create `requirements.txt` listing all external libraries used by `scripts/run_local_agent.py`, `scripts/git_manager.py, `scripts/task_utils.py",
      "plan": "Scan `scripts/run_local_agent.py` and list all non-standard library imports.\nScan `scripts/git_manager.py` and list all non-standard library imports.\nScan `scripts/task_utils.py` and list all non-standard library imports.\nCompile a single, unique list of all external dependencies identified in the previous steps.\nCreate a new file named `requirements.txt` in the project's root directory.\nAdd each unique dependency from the compiled list to `requirements.txt`, with each library on a new line.",
      "acceptance": [
        "`requirements.txt` exists"
      ],
      "dependencies": [
        "2.1",
        "2.2",
        "2.3"
      ]
    },
    {
      "id": "2.5",
      "status": "+",
      "title": "Environment variables template",
      "description": "Provide `.env.example` containing placeholders for required API keys and settings.",
      "plan": "1. Create the `.env.example` file in the project root. 2. Add placeholder variables for API keys needed by `litellm` (e.g., `OPENAI_API_KEY=your_key_here`). 3. Include comments to explain each variable's purpose.",
      "acceptance": [
        "`.env.example` exists and documents each variable."
      ],
      "dependencies": [
        "2.1"
      ]
    },
    {
      "id": "2.6",
      "status": "-",
      "title": "Local setup guide",
      "description": "Author `docs/LOCAL_SETUP.md` with setup and execution instructions.",
      "acceptance": [
        "`docs/LOCAL_SETUP.md` exists and is accurate."
      ],
      "dependencies": [
        "2.3",
        "2.4",
        "2.5"
      ]
    }
  ]
}