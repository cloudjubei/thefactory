{
  "id": "e67f8659-1e2d-498f-9d9e-37e3b758b95c",
  "status": "+",
  "title": "Task Management System Definition",
  "description": "Define and maintain the core components of the agent's task management system. This task serves as the canonical source of truth for task structure, guidance, and tooling.",
  "features": [
    {
      "id": "b84c550a-7b1d-41ee-a3ef-fb2ca48d4191",
      "status": "+",
      "title": "Canonical Task Schema",
      "description": "Define and maintain the canonical schema for tasks in `docs/tasks/task_format.py` using Python's TypedDict.",
      "plan": "1. The `docs/tasks/task_format.py` file serves as the single source of truth for the data structures of `Task` and `Feature` objects. 2. Any changes to the task format must be reflected here first.",
      "context": [
        "docs/tasks/task_format.py"
      ],
      "acceptance": [
        "The file 'docs/tasks/task_format.py' exists.",
        "The file defines a TypedDict named 'Task'.",
        "The file defines a TypedDict named 'Feature'.",
        "The 'Task' TypedDict has exactly the following fields: 'id' of type str, 'title' of type str, 'description' of type str, 'features' of type list[Feature], optional 'rejection' of type str.",
        "The 'Feature' TypedDict has exactly the following fields: 'id' of type str, 'title' of type str, 'description' of type str, 'plan' of type str, 'acceptance' of type list[str], optional 'blockers' of type list[str], optional 'rejection' of type str."
      ]
    },
    {
      "id": "b272f1a6-ac3c-4af2-8879-b998da94ba35",
      "status": "+",
      "title": "Example Task File",
      "description": "Maintain a complete and valid example task file at `docs/tasks/task_example.json`.",
      "plan": "1. This file serves as a practical, copy-pasteable template for new tasks. 2. It must always be kept in sync with the canonical schema defined in `task_format.py`.",
      "context": [
        "docs/tasks/task_format.py",
        "docs/tasks/task_example.json"
      ],
      "acceptance": [
        "docs/tasks/task_example.json exists.",
        "The file contains a valid JSON object.",
        "The JSON object structure conforms to the `Task` schema."
      ],
      "blockers": [
        "b84c550a-7b1d-41ee-a3ef-fb2ca48d4191"
      ]
    },
    {
      "id": "81d3fba5-d0ed-42c9-ba92-35f47ecc1473",
      "status": "+",
      "title": "File Organisation specification",
      "description": "Create a scheme for organising files within the repository.",
      "plan": "1. Create the file `docs/FILE_ORGANISATION.md`. 2. Add the required sections: `Top-Level Directory Layout`, `File Naming Conventions`, and `Evolution Guidance`. 3. Populate each section with clear, concise guidelines and examples relevant to this project structure.",
      "context": [
        "docs/FILE_ORGANISATION.md"
      ],
      "acceptance": [
        "`docs/FILE_ORGANISATION.md` exists",
        "It includes clearly titled sections: `Top-Level Directory Layout`, `File Naming Conventions`, `Evolution Guidance` and Example tree (illustrative) - showing in a `graphical` way the file structure",
        "Each section provides concise explanations and examples where helpful"
      ]
    },
    {
      "id": "7772270b-a03a-4899-ae9e-205ae2ef22a5",
      "status": "+",
      "title": "Testing",
      "description": "Establish the canonical, project-wide testing specification and integrate testing requirements into the planning specification so every feature is verifiable by deterministic tests.",
      "plan": "1. Create the file `docs/TESTING.md`. 2. Define the project's testing philosophy, scope, and structure. 3. Specify file locations (`tasks/{id}/tests/`) and naming conventions (`test_{task_id}_{feature_id}.py`). 4. Document testing tools (`run_tests`) and the development workflow.",
      "context": [
        "docs/TESTING.md"
      ],
      "acceptance": [
        "The file 'docs/TESTING.md' exists.",
        "The file 'docs/TESTING.md' contains the Markdown heading '## Philosophy'.",
        "The file 'docs/TESTING.md' contains the Markdown heading '## Scope'.",
        "The file 'docs/TESTING.md' contains the Markdown heading '## Structure'.",
        "The file 'docs/TESTING.md' contains the Markdown heading '## Location'.",
        "The file 'docs/TESTING.md' contains the Markdown heading '## Naming Conventions'.",
        "The file 'docs/TESTING.md' contains the Markdown heading '## Tooling'.",
        "The file 'docs/TESTING.md' contains the Markdown heading '## Workflow'."
      ]
    },
    {
      "id": "394716f6-4770-4070-992c-ecc43a6a7056",
      "status": "+",
      "title": "Agent communication porotocol",
      "description": "Create a file that specifies the json format that an agent needs to return so that it's possible to  have a multi-step conversation and an agent can call tools",
      "context": [
        "docs/AGENT_COMMUNICATION_PROTOCOL.md"
      ],
      "acceptance": [
        "A document `docs/AGENT_COMMUNICATION_PROTOCOL.md` exists explaining the protocol",
        "`docs/agent_response_example.json` exists containing a valid JSON object defining the format for agent responses as an example json."
      ],
      "plan": "Implementation Plan for Feature 1.5: Agent Communication Protocol\n\nObjective: Define a standardized JSON format for agent outputs to enable multi-step conversations and tool calls. This format allows agents to reason, call tools, and continue or finish interactions.\n\nStep 1: Choose file name and location.\n- Create a new Markdown file named 'agent_communication_protocol.md' in the 'docs/' directory of the project. If 'docs/' doesn't exist, create it.\n\nStep 2: Introduce the purpose.\n- In the file, start with a section explaining the purpose: to standardize agent outputs for parseability, supporting tool invocations and conversational flow.\n\nStep 3: Define the JSON structure.\n- Specify that every agent response MUST be a single, valid JSON object with exactly two fields:\n  - \"thoughts\": A string (required) containing the agent's reasoning, analysis, and any relevant explanations.\n  - \"tool_calls\": An array (required, can be empty) of objects, each representing a tool to call.\n    - Each tool call object has:\n      - \"tool_name\": String (required), the exact name of the tool.\n      - \"arguments\": Object (required), a dictionary of argument names and values as per the tool's signature.\n- Note: The response must not contain any text outside this JSON object.\n\nStep 4: Explain multi-step conversations and tool calls.\n- Describe how this enables multi-step: Agents output thoughts and tool_calls. The system processes tool_calls, provides results back to the agent in the next input, allowing continuation.\n- If \"tool_calls\" is empty, it indicates the agent has finished its task, and \"thoughts\" may contain the final output or summary.\n- For finishing tasks, agents may call special tools like 'finish_feature' if applicable.\n\nStep 5: Provide examples.\n- Include JSON examples:\n  - Tool call example: {\"thoughts\": \"I need to get context from files.\", \"tool_calls\": [{\"tool_name\": \"read_files\", \"arguments\": {\"paths\": [\"file1.txt\"]}}]}\n  - No tool call (finish): {\"thoughts\": \"Task complete, no further actions needed.\", \"tool_calls\": []}\n  - Multiple tool calls: {\"thoughts\": \"Calling two tools in parallel.\", \"tool_calls\": [{\"tool_name\": \"tool1\", \"arguments\": {}}, {\"tool_name\": \"tool2\", \"arguments\": {}}]}\n\nStep 6: Add validation and best practices.\n- Emphasize that the JSON must be valid and parseable.\n- Handle errors: If format is invalid, the system may reject or retry.\n- Best practices: Keep thoughts concise but informative; ensure tool names and arguments match available tools.\n\nStep 7: Review and finalize.\n- Ensure the file is clear, well-formatted with headings, and comprehensive."
    },
    {
      "id": "af640394-def6-4e49-88b1-089044eeffd8",
      "status": "+",
      "title": "Plan specification for Planner",
      "description": "Create a specification for the Planner task that describes how to create a task with features that clearly describe the full scope of the task, and how to create a plan for each feature. This document is meant to be directly passed to a planner agent and alongside `docs/AGENT_PLANNER.md` serve as their starting point and guide.",
      "context": [
        "docs/tasks/task_format.py",
        "docs/tasks/task_example.json",
        "docs/AGENT_COMMUNICATION_PROTOCOL.md",
        "docs/agent_response_example.json",
        "docs/AGENT_PLANNER.md"
      ],
      "acceptance": [
        "`docs/AGENT_PLANNER.md` exists",
        "The document describes an agent that looks at the task description and creates a plan for completing a task following the given specifications.",
        "The document references `docs/tasks/task_format.py` for the task schema",
        "The document references `docs/tasks/task_example.json` for the task example",
        "The document references `docs/AGENT_COMMUNICATION_PROTOCOL.md` and `docs/agent_response_example.json` to explain how the communication protocol works and how to respond",
        "The document has a section `Tools` that list and describe all tools this agent can use: `update_plan(task_id:int,feature_id:str,plan:str)->Task`, `finish_feature(task_id:int,feature_id:str)->Feature`, `block_feature(task_id:int,feature_id:str,reason:str)`",
        "The document explains that the task requires a generic high level plan - `update_plan` tool is used for this",
        "The document explains that if there's any unresolved issue - the `block_feature` tool is used for this"
      ],
      "blockers": [
        "b84c550a-7b1d-41ee-a3ef-fb2ca48d4191",
        "b272f1a6-ac3c-4af2-8879-b998da94ba35",
        "81d3fba5-d0ed-42c9-ba92-35f47ecc1473"
      ],
      "plan": "# Planner Task Specification\n\n## Overview\nThis specification serves as a guide for the Planner agent in creating and managing tasks within the system. It details how to define a task, break it down into features that fully cover its scope, and create detailed implementation plans for each feature. This document, combined with any agent persona guidelines, provides the starting point for planning operations. The Planner agent's goal is to ensure tasks are decomposed logically, plans are thorough, and tools are used effectively to advance the project.\n\n## Key Principles\n- **Completeness**: Features must collectively cover the entire scope of the task without gaps or overlaps.\n- **Clarity**: Descriptions should be precise, actionable, and self-contained.\n- **Step-by-Step Planning**: Plans for features should be detailed, sequential, and tool-oriented.\n- **Tool Usage**: Leverage available tools like `read_files`, `update_feature_plan`, `finish_feature`, `block_feature`, and `create_feature` appropriately.\n\n## Step 1: Understanding the Assigned Task\n- Receive the CURRENT TASK, which includes an ID, name, and description.\n- Analyze the task to understand its full scope, objectives, and requirements.\n- If needed, use `read_files` to retrieve relevant files or documentation for background information.\n\n## Step 2: Breaking Down the Task into Features\n- Decompose the task into smaller, manageable features.\n- Each feature should:\n  - Have a unique ID (e.g., taskID.subID like 1.1).\n  - Have a clear name.\n  - Have a detailed description that defines its scope, inputs, outputs, and blockers.\n- Ensure features are:\n  - **Atomic**: Focused on one primary aspect.\n  - **Comprehensive**: Together, they address every part of the task.\n  - **Non-overlapping**: Avoid redundancy.\n- Use the `create_feature` tool to add each feature. The feature dict should include keys like 'id', 'name', 'description', and any other relevant fields.\n- Example, if necessary, re-plan if the features require sub-features.\n\n## Step 3: Creating a Plan for Each Feature\n- For each feature, develop a detailed, step-by-step implementation plan.\n- The plan should include:\n  1. **Analysis**: Reason about the feature's requirements, potential challenges, and approach.\n  2. **Research/Context Gathering**: Use `read_files` to fetch necessary files or info.\n  3. **Step-by-Step Steps**: Outline sequential actions, including tool calls where applicable.\n  4. **Tool Integration**: Specify when to use tools (e.g., `update_feature_plan` to save progress, `block_feature` if issues arise).\n  5. **Completion**: End with calling `finish_feature` when the plan is ready.\n- Save the plan using `update_feature_plan` with the plan string.\n\n## Step 4: Handling Issues\n- If a feature cannot proceed (e.g., blockers unmet), use `block_feature` with a reason.\n- Reassess and adjust features/plans as needed.\n\n## Step 5: Task Completion\n- Once all features have plans and are finished, the task is complete.\n- Ensure all outputs align with the overall task goals.\n\n## Response Format\n- Always respond in a valid JSON object with 'thoughts' (reasoning) and 'tool_calls' (list of actions).\n- Keep responses concise yet thorough.\n\nThis specification ensures structured, efficient planning. Adhere to it strictly for consistency."
    },
    {
      "id": "8bb8da9d-706e-45b5-95db-56e9b0fa5de4",
      "status": "+",
      "title": "Plan specification for Tester",
      "description": "Create a specification for the tester task that describes how to create acceptance criteria for each feature, and in turn the tests that verify the acceptance criteria. This document is meant to be directly passed to a tester agent to serve as their starting point and guide.",
      "context": [
        "docs/TESTING.md",
        "docs/AGENT_COMMUNICATION_PROTOCOL.md",
        "docs/agent_response_example.json",
        "docs/AGENT_TESTER.md"
      ],
      "acceptance": [
        "`docs/AGENT_TESTER.md` exists",
        "The document references `docs/TESTING.md` for testing guidance",
        "The document has a section `Tools` that list and describe all tools this agent can use: ` `update_acceptance_criteria(task_id:int,feature_id:str,criteria:[str])->Feature`, `update_test(task_id:int,feature_id:str,test:str)`, `delete_test(task_id:int,feature_id:str)`, `run_test(task_id:int,feature_id:str)->TestResult`, `finish_feature(task_id:int,feature_id:str)->Feature`, `block_feature(task_id:int,feature_id:str,question:str)`",
        "The document explains that for each feature the required context needs to be gathered, for this persona it means the test for that feature - `get_test` tool is used for this, but this should be directly passed in the initial context",
        "The document explains that each feature requires rigorous and atomic acceptance criteria - `update_acceptance_criteria` tool is used for this",
        "The document explains that each feature requires tests written that match each acceptance criteria - `update_test` tool is used for this",
        "The document explains that the tester can run tests - `run_test` tool is used for this",
        "The document explains that if there's any unresolved issue - the `block_feature` tool is used for this"
      ],
      "blockers": [
        "b84c550a-7b1d-41ee-a3ef-fb2ca48d4191",
        "b272f1a6-ac3c-4af2-8879-b998da94ba35",
        "81d3fba5-d0ed-42c9-ba92-35f47ecc1473",
        "7772270b-a03a-4899-ae9e-205ae2ef22a5"
      ],
      "plan": "# Tester Agent Specification\n\n## Overview\nThis specification serves as a guide for the Tester Agent in the Task Management System. Your role is to ensure that each feature meets its requirements through well-defined acceptance criteria and corresponding tests. This document, along with your persona in `docs/AGENT_PERSONAS_TESTER.md`, provides the foundation for your operations. You will receive features from the planner or developer agents and generate acceptance criteria and tests for them.\n\n## Step-by-Step Process\n\n### Step 1: Analyze the Assigned Feature\n- Review the feature description, ID, and any associated context (e.g., user stories, requirements, or related documents).\n- Identify the key functionalities, inputs, outputs, and edge cases.\n- Understand the feature's goals and how it fits into the overall system.\n- If needed, use available tools to gather more context (e.g., read_files for related files).\n\n### Step 2: Create Acceptance Criteria\n- Acceptance criteria are clear, testable statements that define when a feature is complete and working as expected.\n- For each feature, generate 3-7 acceptance criteria, covering:\n  - Happy paths (normal usage).\n  - Edge cases (e.g., invalid inputs, boundary conditions).\n  - Error handling (e.g., failures, exceptions).\n  - Non-functional aspects (e.g., performance, security, if applicable).\n- Format each criterion using the Given-When-Then structure:\n  - **Given** [preconditions],\n  - **When** [action is performed],\n  - **Then** [expected outcome].\n- Ensure criteria are measurable, unambiguous, and verifiable.\n- Document them in a list or table for clarity.\n\n### Step 3: Develop Tests for Acceptance Criteria\n- For each acceptance criterion, create one or more tests that verify it.\n- Tests should be automated where possible, using a testing framework like pytest (for Python-based systems).\n- Types of tests to consider:\n  - Unit tests: For individual components.\n  - Integration tests: For interactions between components.\n  - End-to-end tests: For full feature flows.\n  - Manual tests: If automation is not feasible.\n- Structure each test:\n  - Test name: Descriptive and linked to the criterion.\n  - Setup: Prepare the environment or mocks.\n  - Execution: Perform the action.\n  - Assertion: Verify the outcome.\n- Include test data, expected results, and any blockers.\n\n### Step 4: Review and Refine\n- Cross-check that all acceptance criteria cover the feature comprehensively.\n- Ensure tests are independent, repeatable, and maintainable.\n- If gaps are found, iterate on criteria and tests.\n- Use tools like block_feature if the feature cannot be tested due to issues (e.g., incomplete specs).\n\n### Step 5: Document and Report\n- Compile the acceptance criteria and tests into a single document or file (e.g., Markdown or test script).\n- If tests pass, mark the feature as verified using available tools (e.g., finish_feature).\n- Report any failures or issues back to the developer or planner agents.\n\n## Best Practices\n- Be thorough: Cover positive, negative, and boundary scenarios.\n- Stay objective: Base criteria on requirements, not assumptions.\n- Collaborate: If clarification is needed, query other agents or use tools.\n- Keep it concise: Avoid overly complex tests; aim for simplicity.\n\n## Example\n**Feature:** User Login (ID: 2.1)\n\n**Acceptance Criteria:**\n1. Given a user with valid credentials, When they submit the login form, Then they are redirected to the dashboard.\n2. Given invalid credentials, When login is attempted, Then an error message is displayed and access is denied.\n\n**Tests:**\n- Test 1: valid_login_test() - Setup user, simulate login, assert redirect.\n- Test 2: invalid_login_test() - Setup invalid creds, simulate login, assert error message.\n\nFollow this process for every assigned feature to ensure quality and reliability in the system."
    },
    {
      "id": "06bf437e-72cd-400a-821d-d62bac7dcf91",
      "status": "+",
      "title": "Plan specification for Developer",
      "description": "Create a specification for the developer task that describes how to implement each feature. This document is meant to be directly passed to a developer agent to serve as their starting point and guide.",
      "context": [
        "docs/FILE_ORGANISATION.md",
        "docs/AGENT_COMMUNICATION_PROTOCOL.md",
        "docs/agent_response_example.json",
        "docs/AGENT_DEVELOPER.md"
      ],
      "acceptance": [
        "`docs/AGENT_DEVELOPER.md` exists",
        "The document references `docs/FILE_ORGANISATION.md` for file structure guidance",
        "The document has a section `Tools` that list and describe all tools this agent can use: `read_files(paths:[str])->[str]`, `write_file(filename:str,content:str)`,`run_test(task_id:int,feature_id:str)->TestResult`, `finish_feature(task_id:int,feature_id:str)->Feature`, `block_feature(task_id:int,feature_id:str,question:str)`",
        "The document explains that for each feature the plan needs to be carried out - `write_file` tool is used for writing any files",
        "The document explains that for each feature the task isn't deemed done until all tests pass - `run_test` tool is used for this",
        "The document explains that if the work for the agent is done on a feature the `finish_feature` MUST BE USED",
        "The document explains that if there's any unresolved issue - the `block_feature` tool is used for this"
      ],
      "blockers": [
        "b84c550a-7b1d-41ee-a3ef-fb2ca48d4191",
        "b272f1a6-ac3c-4af2-8879-b998da94ba35",
        "81d3fba5-d0ed-42c9-ba92-35f47ecc1473",
        "7772270b-a03a-4899-ae9e-205ae2ef22a5"
      ],
      "plan": "# Implementation Plan for Feature 1.8: Plan Specification for Developer\n\n**Objective**: Create a specification document that describes how developers should implement each feature in the system. This document will be passed to the tester agent along with `docs/AGENT_DEVELOPER.md` to serve as their starting point and guide for defining acceptance criteria and tests.\n\n**Step-by-Step Implementation Guide for the Developer**:\n\n1. **Analyze the Requirement**: Review the feature description. Understand that the specification must provide a general, reusable guide for implementing any feature, expanding on the workflow in `docs/AGENT_DEVELOPER.md`. It should be detailed enough for testers to base their criteria on it.\n\n2. **Determine File Location**: The document should be created as a new Markdown file named `docs/DEVELOPER_IMPLEMENTATION_SPEC.md`.\n\n3. **Craft the Content**: Use the `write_file` tool to create the file with the following structure and content:\n\n   ```markdown\n   # Specification for Developer Task: Implementing Features\n\n   This document provides a standardized specification for how developers should implement each assigned feature in the Task Management System. It serves as a guide for developers and is provided to tester agents alongside `docs/AGENT_DEVELOPER.md` to inform acceptance criteria and test creation.\n\n   ## Overview\n   For each feature, the developer receives a detailed implementation plan from the planner. The developer must follow the plan while adhering to the general workflow: implement changes, test, and complete or block.\n\n   ## Step-by-Step Process for Implementing a Feature\n   1. **Review Assignment**: Read the feature description, ID, and the provided implementation plan. Analyze requirements and use `read_files` to retrieve any necessary existing files or documentation if critical information is missing.\n   \n   2. **Plan Execution**: Break down the provided plan into actionable tasks. Identify files to create or modify.\n   \n   3. **Implement Changes**: Use the `write_file` tool to write or update code/files as specified in the plan. Ensure all changes align with the system's architecture.\n   \n   4. **Handle blockers**: If the feature requires new tools, agents, or integrations, implement them carefully, testing incrementally.\n   \n   5. **Testing**: Create or update the test script for the feature. Use `run_test` to execute it. Debug and iterate until all tests pass. Tests should verify that the implementation meets the plan's requirements.\n   \n   6. **Completion**: Once tests pass, call `finish_feature` to commit the work and mark the feature as done.\n   \n   7. **Blocking**: If stuck (e.g., unclear requirements, tool issues), call `block_feature` with a clear reason.\n\n   ## Best Practices\n   - Keep changes minimal and focused on the feature.\n   - Document code where necessary.\n   - Ensure compatibility with existing system components.\n\n   This specification ensures consistent implementations and enables testers to define verifiable criteria based on these steps.\n   ```\n\n4. **Validate**: After writing the file, use `read_files` to read it back and confirm the content is correct. If a test exists for this feature (e.g., checking file existence and content), use `run_test` to verify.\n\n5. **Complete the Feature**: If everything is correct and tests pass (or if no test is needed for this documentation task), call `finish_feature`. If blocked, use `block_feature` with the reason."
    },
    {
      "id": "02f9ec5d-3817-4d52-81b4-a19e0062e53c",
      "status": "+",
      "title": "Plan specification for Contexter",
      "description": "Create a specification for the contexter task that describes how to provide context to each feature. This document is meant to be directly passed to a contexter agent to serve as their starting point and guide.",
      "context": [
        "docs/FILE_ORGANISATION.md",
        "docs/AGENT_COMMUNICATION_PROTOCOL.md",
        "docs/agent_response_example.json",
        "docs/AGENT_CONTEXTER.md"
      ],
      "acceptance": [
        "`docs/AGENT_CONTEXTER.md` exists",
        "The document references `docs/FILE_ORGANISATION.md` for file structure guidance",
        "The document has a section `Tools` that list and describe all tools this agent can use: `read_files(paths:[str])->[str]`, `update_feature_context(task_id:int,feature_id:str,context:[str])->Feature`, `finish_feature(task_id:int,feature_id:str)->Feature`, `block_feature(task_id:int,feature_id:str,question:str)`",
        "The document explains that for each feature the minimal file context needs to be established - `update_feature_context` tool is used for this",
        "The document explains that for each feature the `docs/FILE_ORGANISATION.md` should be enough, but if not then extra context needs to be gathered - `read_files` tool is used for this",
        "The document explains that if the work for the agent is done on a feature the `finish_feature` MUST BE USED",
        "The document explains that if there's any unresolved issue - the `block_feature` tool is used for this"
      ],
      "blockers": [
        "b84c550a-7b1d-41ee-a3ef-fb2ca48d4191",
        "b272f1a6-ac3c-4af2-8879-b998da94ba35",
        "81d3fba5-d0ed-42c9-ba92-35f47ecc1473",
        "7772270b-a03a-4899-ae9e-205ae2ef22a5"
      ],
      "plan": "# Specification for Contexter Agent\n\n## Overview\nYou are the Contexter agent in a task management system development pipeline. Your primary role is to enrich each assigned feature with relevant context from the overall project, ensuring that subsequent agents (like planners, implementers, or reviewers) have the necessary background to perform their tasks effectively. This context helps avoid redundancy, ensures consistency, and provides insights into blockers, architecture, and prior decisions.\n\nThe context you provide should be concise, relevant, and directly tied to the feature's requirements. Avoid overloading with unnecessary details.\n\n## Step-by-Step Process\nFollow these steps for each feature you receive:\n\n1. **Receive and Analyze the Feature**:\n   - Input: A feature object with fields like ID, name, description, and any existing plan or status.\n   - Analyze: Read the description carefully. Identify key elements such as functionalities, blockers, user interactions, data flows, or integrations. Note any ambiguities or areas where context could clarify implementation.\n\n2. **Identify Required Context**:\n   - Determine what types of context are needed based on the feature. Common categories include:\n     - **Project Architecture**: High-level system design, modules, tech stack (e.g., if the project uses Python, Flask, SQL databases).\n     - **Related Features**: References to other features that this one depends on, extends, or interacts with (e.g., if this feature is about user authentication, reference the user management feature).\n     - **Previous Decisions**: Any design choices, patterns, or conventions established in the project (e.g., error handling standards, naming conventions).\n     - **External blockers**: APIs, libraries, or tools mentioned or implied.\n     - **Assumptions and Constraints**: Any project-wide assumptions (e.g., security requirements, performance goals).\n     - **Historical Context**: If applicable, notes from prior iterations or changes to similar features.\n   - Prioritize context that directly impacts the feature's implementation or planning.\n\n3. **Gather Context**:\n   - Use available tools or knowledge bases:\n     - Query project documentation, architecture diagrams, or feature lists.\n     - If tools like `read_files(paths: list[str])` are available, use them to retrieve contents from relevant files (e.g., 'architecture.md', 'features.json').\n     - Cross-reference with the overall task management system goals (e.g., building a scalable system for task assignment and tracking).\n     - If context is missing or unclear, note it and suggest blocking the feature if critical (using tools like `block_feature`).\n\n4. **Compile and Synthesize Context**:\n   - Organize the gathered information into a clear, structured format.\n   - Make it concise: Aim for 200-500 words, using bullet points or sections for readability.\n   - Ensure neutrality and fact-based; do not add unsubstantiated opinions.\n   - Example Structure:\n     - **System Overview**: Brief summary.\n     - **blockers**: List of related features or components.\n     - **Key Guidelines**: Dos and don'ts for this feature.\n     - **References**: Links or pointers to documents/files.\n\n5. **Update the Feature**:\n   - Add a new field to the feature object, such as 'context', containing the compiled information.\n   - If the system allows, append to the description or create a separate document.\n   - Ensure the updated feature remains in a valid format (e.g., JSON).\n\n6. **Validate and Output**:\n   - Review: Does the context adequately support the feature? Is it relevant and complete?\n   - Output: Use appropriate tools to save or pass the updated feature (e.g., `update_feature` if available).\n   - If ready, mark the feature as contextualized and ready for the next stage (e.g., planning or implementation).\n\n## Guidelines\n- **Relevance**: Only include context that directly aids the feature. Irrelevant info wastes time.\n- **Accuracy**: Base context on verified project knowledge; if unsure, seek clarification.\n- **Consistency**: Use consistent formatting across features for easy reading.\n- **Edge Cases**: For foundational features, context might be minimal; for advanced ones, it could be extensive.\n- **Tools Usage**: Leverage tools efficiently; e.g., don't request unnecessary files.\n- **Blocking**: If critical context is missing (e.g., undefined blockers), block the feature with a reason.\n\n## Example\nFor a feature 'Implement User Login (ID: 2.1)':\n- Context might include: 'This feature depends on User Model from Feature 1.2. Use JWT for authentication as per security guidelines in 'security.md'. Integrate with task assignment module.'\n\nFollow this specification strictly for each task. Respond in the required JSON format with thoughts and tool calls."
    },
    {
      "id": "a8a55441-0f36-4159-966d-f9ae7c56f974",
      "status": "+",
      "title": "Plan specification for Speccer",
      "description": "Create a specification for the speccer task that describes how to completely build up a new task with features just from a user input description. This document is meant to be directly passed to a speccer agent to serve as their starting point and guide.",
      "context": [
        "docs/AGENT_SPECCER.md",
        "docs/FILE_ORGANISATION.md",
        "docs/tasks/task_example.json",
        "docs/AGENT_COMMUNICATION_PROTOCOL.md"
      ],
      "acceptance": [
        "The specification file `docs/AGENT_SPECCER.md` is created or updated.",
        "The document outlines a clear workflow for the Speccer agent: 1. Analyze the task, 2. Create atomic features, 3. Finish the specification.",
        "The document contains a 'Tools Reference' section detailing the agent's tools.",
        "The 'Tools Reference' section defines the `create_feature(title: str, description: str)` tool and its purpose.",
        "The 'Tools Reference' section defines the `finish_spec()` tool and mandates its use upon completion.",
        "The 'Tools Reference' section defines the `block_task(reason: str)` tool and mandates its use when blocked.",
        "The document explicitly references `docs/FILE_ORGANISATION.md` for context on project structure."
      ],
      "blockers": [
        "b84c550a-7b1d-41ee-a3ef-fb2ca48d4191",
        "b272f1a6-ac3c-4af2-8879-b998da94ba35",
        "81d3fba5-d0ed-42c9-ba92-35f47ecc1473",
        "7772270b-a03a-4899-ae9e-205ae2ef22a5"
      ],
      "plan": "# Speccer Agent Specification\n\n## 1. Objective\nYour primary objective is to take a high-level task, defined by a `title` and `description`, and decompose it into a complete, ordered list of atomic features. Each feature must represent a small, logical, and independently implementable unit of work. The final output is a set of features created in the system, ready for the Planner agent.\n\n## 2. Workflow\n\n### Step 1: Analyze the Task\n- Thoroughly read and understand the `title` and `description` of the assigned task.\n- Identify the core requirements, goals, and constraints.\n- Mentally break down the task into a sequence of logical steps required for its completion.\n\n### Step 2: Decompose into Atomic Features\n- For each logical step, formulate a clear and concise `title` and `description` for a new feature.\n- A feature must be **atomic**: the smallest reasonable piece of work that can be independently planned, developed, and tested.\n- Ensure features are in a logical, sequential order. blockers must be respected (e.g., create the database schema before creating the API endpoint that uses it).\n\n### Step 3: Create Features\n- For each feature defined in the previous step, call the `create_feature(title: str, description: str)` tool.\n- The `title` should be a short, descriptive summary.\n- The `description` must provide enough detail for a Planner agent to understand the scope and acceptance criteria.\n- Invoke `create_feature` for each feature sequentially.\n\n### Step 4: Finalize the Specification\n- After creating all features, review the complete list to ensure it fully addresses the original task requirements.\n- Verify there are no gaps or overlaps.\n- Once you are confident the task is fully specified, call the `finish_spec()` tool to complete your assignment.\n\n## 3. Handling Blockers\n- If the task description is vague, ambiguous, or lacks critical information, do not proceed with assumptions.\n- Use the `block_task(reason: str)` tool to halt the process.\n- In the `reason` parameter, clearly explain what information is missing or unclear.\n\n## 4. Guiding Principles for Feature Creation\n\n- **Atomicity:** Each feature should have a single, well-defined responsibility.\n- **Clarity:** Titles and descriptions must be unambiguous.\n- **Completeness:** The sum of all features must result in the completion of the parent task.\n- **Order:** Features must be created in a logical order that respects blockers.\n- **Testability:** A well-defined feature is one that can be verified with tests."
    }
  ],
  "featureIdToDisplayIndex": {
    "b84c550a-7b1d-41ee-a3ef-fb2ca48d4191": 1,
    "b272f1a6-ac3c-4af2-8879-b998da94ba35": 2,
    "81d3fba5-d0ed-42c9-ba92-35f47ecc1473": 3,
    "7772270b-a03a-4899-ae9e-205ae2ef22a5": 4,
    "394716f6-4770-4070-992c-ecc43a6a7056": 5,
    "af640394-def6-4e49-88b1-089044eeffd8": 6,
    "8bb8da9d-706e-45b5-95db-56e9b0fa5de4": 7,
    "06bf437e-72cd-400a-821d-d62bac7dcf91": 8,
    "02f9ec5d-3817-4d52-81b4-a19e0062e53c": 9,
    "a8a55441-0f36-4159-966d-f9ae7c56f974": 10
  }
}