{
  "id": 5,
  "status": "-",
  "title": "Local app",
  "description": "Create a local Electron+React app to handle project management, see tasks and feature status, update task fields/notes, see all the documents in a nice Markdown display, be able to launch/manage agents running locally and overview status in git (i.e. being able to see if an agent is working on something or not), getting notifications when work is done etc., see all child projects and manage them in the future. Ideally this app is the go-to place for anyone to use THIS project (the factory) and wouldn't have to run any scripts or code manually. A big feature of this should also be access to some sort of chat interface so that it should be possible to talk with a chosen LLM about the whole project. It should be possible to give the LLM chat access to the same tools that the agents use but in a restricted manner, so only the ones that are read-only. It should also be possible to configure further ways of connecting to LLMS for chat and for agents other than the currently chosen litellm. For instance, there's an app LM Studio that allows connecting to a locally running LLM via API calls. The project for the local app exists detailing the steps involved in creating a local app for project management. This will be the first project to stem from this one. It should follow the same exact principles as this project, but it will live in its own separate repository. This project is just meant to kickstart the whole scaffolding and specification. If any extra functionality comes into this project, it should be easy to adapt this Local app project to use the exact same ideas. Notes: Currently I'm using VSCode to view the project, run everything, see tasks etc. It would be ideal to have a dedicated app for managing the project, viewing tasks, seeing progress etc. For being able to see how the agents fares etc. Cline the plugin for VSCode does something like this and maybe it makes sense to even built upon a fork on this. One thing to keep in mind is that we want to be really third-party independent. If we can create something ourselves we should. The only question is how it integrates with the project. If maintaining such a service/dependency is too heavy, then using a third party solution makes sense. Each third party solution should be its own tasks, with documented features and explanations as to why it was chosen etc.",
  "features": [
    {
      "id": "5.1",
      "status": "-",
      "title": "Bootstrap Local App repository and add as submodule",
      "description": "Create a new repository (e.g., factory-local-app) initialized with standard files (README with scope/goals, LICENSE, .gitignore, .editorconfig, .nvmrc, package.json), docs/ folder with placeholders (ARCHITECTURE.md, DEVELOPMENT.md), and minimal Node project setup. Add it to this factory repo as a Git submodule under projects/local-app. Acceptance: submodule exists under projects/local-app; repo contains the specified files; README explains project purpose and alignment to the factory; dev install command and dev script stub documented.",
      "plan": "Implementation plan for 5.1: Bootstrap Local App repository and add as submodule\n\n1) Create the remote repository\n- Name: factory-local-app (or similar)\n- Description: \"Local Electron+React app scaffold for project/agent management aligned with the Factory.\"\n- Visibility: per project policy (public/private)\n- Default branch: main\n- License: MIT (add license file in repo)\n\n2) Initialize the repository locally\n- Prepare a working directory and initialize git:\n  - git clone <new_repo_url> factory-local-app\n  - cd factory-local-app\n- Initialize Node version via .nvmrc (use current LTS used by the factory; example below)\n\n3) Create initial file/folder structure\n- Root files:\n  - README.md\n  - LICENSE\n  - .gitignore\n  - .editorconfig\n  - .nvmrc\n  - package.json\n- Folders:\n  - docs/\n    - ARCHITECTURE.md\n    - DEVELOPMENT.md\n  - src/\n    - index.js\n\n4) Populate files with minimal, acceptance-compliant content\n- README.md (must explain project purpose, alignment with the factory, and have install/dev script docs)\n  Suggested content:\n  Title: Factory Local App\n  Purpose: A local Electron+React app to manage Factory projects, tasks, agent status, documents (Markdown), notifications, and chat with LLMs via read-only tools. This repo is the standalone implementation aligned with the Factory principles.\n  Alignment: Shares architecture and conventions with the Factory; intended to integrate seamlessly and evolve independently while remaining compatible with Factory workflows and tooling.\n  Status: Bootstrap scaffold only; Electron/React wiring to follow in subsequent features.\n  Requirements: Node (see .nvmrc), npm.\n  Install: npm install\n  Develop: npm run dev (currently a stub that logs a message; see docs/DEVELOPMENT.md)\n  Next steps: Electron-React scaffolding, agent read-only tool adapters, LLM provider adapters (LiteLLM, LM Studio, etc.).\n\n- LICENSE: Standard MIT text with your name/year.\n\n- .gitignore (Node + OS/editor basics):\n  node_modules/\n  dist/\n  .DS_Store\n  .env\n  .env.*\n  npm-debug.log*\n  yarn-debug.log*\n  yarn-error.log*\n  .vscode/\n\n- .editorconfig (common defaults):\n  root = true\n\n  [*]\n  charset = utf-8\n  end_of_line = lf\n  insert_final_newline = true\n  indent_style = space\n  indent_size = 2\n  trim_trailing_whitespace = true\n\n- .nvmrc: set Node LTS (example):\n  20.17.0\n\n- package.json (minimal Node project setup with a dev script stub):\n  {\n    \"name\": \"@factory/local-app\",\n    \"version\": \"0.1.0\",\n    \"private\": true,\n    \"description\": \"Local Electron+React app scaffold for Factory project management.\",\n    \"license\": \"MIT\",\n    \"type\": \"module\",\n    \"engines\": { \"node\": \">=20.17.0\" },\n    \"scripts\": {\n      \"dev\": \"node src/index.js\",\n      \"validate\": \"node -e \\\"console.log('TODO: add validation/linting')\\\"\"\n    }\n  }\n\n- docs/ARCHITECTURE.md (placeholder):\n  Overview: High-level goals (project/task/agent management UI, docs viewer, notifications, LLM chat with read-only tool access).\n  Principles: Local-first, third-party independent when practical; modular adapters for LLM providers; alignment with Factory repo conventions.\n  Modules (planned): UI (Electron+React), Data layer (reads project files/git), Agent status integration, LLM provider adapters.\n  Security/Privacy: Local data, restricted read-only tool invocation for chat.\n\n- docs/DEVELOPMENT.md (placeholder):\n  Prerequisites: Node per .nvmrc, npm, git.\n  Setup: nvm use; npm install.\n  Commands: npm run dev (currently prints a stub message); npm run validate.\n  Conventions: Editorconfig, future lint/formatting planned.\n  Next: Add Electron+React scaffolding and dev runner; document environment variables when introduced.\n\n- src/index.js (stub dev entry):\n  console.log(\"Factory Local App: dev environment not yet implemented. See docs/DEVELOPMENT.md.\");\n  process.exit(0);\n\n5) Commit and push the bootstrap\n- git add .\n- git commit -m \"chore: bootstrap factory-local-app scaffold (docs, config, dev stub)\"\n- git push origin main\n\n6) Add as a submodule in the Factory repo\n- From the root of the Factory repo:\n  - git submodule add -b main <new_repo_url> projects/local-app\n  - git commit -m \"chore(projects): add local app as git submodule\"\n- If submodules are already initialized, ensure they are updated:\n  - git submodule update --init --recursive\n\n7) Verify acceptance criteria\n- Submodule exists under projects/local-app pointing to the new repo.\n- The submodule's repo contains: README.md, LICENSE, .gitignore, .editorconfig, .nvmrc, package.json, docs/ARCHITECTURE.md, docs/DEVELOPMENT.md, src/index.js.\n- README explains project purpose and alignment to Factory and documents install and dev script stub (npm install; npm run dev).\n\n8) Notes and considerations\n- Keep this repo independent; future work will add Electron+React and adapter architecture.\n- Third-party integrations (LiteLLM, LM Studio, etc.) will be evaluated and documented as separate tasks with rationale.\n- Ensure Node version stays in sync with the Factory by updating .nvmrc as needed.\n",
      "context": [],
      "acceptance": []
    },
    {
      "id": "5.2",
      "status": "-",
      "title": "Electron + React + TypeScript scaffold",
      "description": "Initialize the app using a modern toolchain (electron-vite with React + TypeScript). Include scripts: dev, build, lint, format. Ensure secure defaults: contextIsolation=true, sandbox where applicable, separate main, preload, and renderer packages. Acceptance: `pnpm/npm run dev` runs the app with React UI placeholder; `... build` yields a runnable app in dist; TypeScript config present; eslint/prettier configured.",
      "plan": "Implementation Plan: Electron + React + TypeScript Scaffold using electron-vite\n\n1) Prerequisites and Repo Setup\n   1. Ensure Node.js >= 18 and pnpm or npm installed.\n   2. Create a new, separate repository for the Local App (e.g., repo name: factory-local-app). Initialize git.\n   3. Add a .gitignore (Node + macOS/Windows defaults). Optionally add .nvmrc/.node-version.\n\n2) Scaffold with electron-vite (React + TypeScript)\n   1. Run the official scaffolder:\n      - Using npm: npm create electron-vite@latest\n      - Using pnpm: pnpm dlx create-electron-vite\n   2. When prompted:\n      - Project name: factory-local-app\n      - Framework: React\n      - Variant: TypeScript\n   3. cd factory-local-app and install deps:\n      - pnpm install (or npm install)\n\n3) Verify Project Structure (separate main/preload/renderer)\n   1. Ensure folders exist (names may vary by template):\n      - electron/main (or src/main): Electron main process\n      - electron/preload (or src/preload): Preload scripts\n      - src/renderer (or src/renderer): React renderer\n   2. Confirm tsconfig(s) exist in root and for sub-packages (if template provides separate ones).\n\n4) Secure BrowserWindow Defaults\n   1. Open main process entry (e.g., electron/main/index.ts or src/main/index.ts):\n      - In new BrowserWindow({ webPreferences: {...} }) set:\n        - preload: path to preload script (resolved with fileURLToPath or join)...\n        - sandbox: true\n        - contextIsolation: true\n        - nodeIntegration: false\n        - webSecurity: true\n        - devTools: process.env.NODE_ENV !== 'production'\n        - disableBlinkFeatures: 'Auxclick' (optional)\n      - Remove/disable any use of the remote module.\n   2. Handle a simple IPC for testing:\n      - ipcMain.handle('ping', () => 'pong')\n\n5) Preload: Minimal, Read-Only, Context Bridge\n   1. In preload (e.g., electron/preload/index.ts):\n      - import { contextBridge, ipcRenderer } from 'electron'\n      - Expose a safe API:\n        contextBridge.exposeInMainWorld('api', {\n          ping: () => ipcRenderer.invoke('ping'),\n          versions: { electron: process.versions.electron, chrome: process.versions.chrome, node: process.versions.node }\n        })\n      - Avoid Node built-ins when sandbox: true (do not import fs/path).\n\n6) Renderer: React Placeholder UI\n   1. In src/renderer (React app entry), add a minimal page:\n      - Show a title like \"Factory Local App\"\n      - Buttons/labels to call window.api.ping() and display \"pong\" result.\n      - Display versions from window.api.versions.\n   2. Ensure TypeScript ambient types for window.api (create src/renderer/env.d.ts):\n      - declare interface Window { api: { ping(): Promise<string>; versions: { electron: string; chrome: string; node: string } } }\n\n7) TypeScript Configuration\n   1. Root tsconfig.json:\n      - \"compilerOptions\": { \"target\": \"ES2020\", \"module\": \"ESNext\", \"strict\": true, \"moduleResolution\": \"Bundler\", \"jsx\": \"react-jsx\", \"types\": [\"node\"] }\n      - Include/Exclude appropriate src paths.\n   2. If template splits tsconfig per package (main/preload/renderer), ensure each has strict: true and appropriate lib/module settings.\n\n8) ESLint + Prettier Setup\n   1. Install dev dependencies:\n      - pnpm add -D eslint @typescript-eslint/parser @typescript-eslint/eslint-plugin eslint-plugin-react eslint-plugin-react-hooks eslint-config-prettier prettier\n   2. Create .eslintrc.cjs:\n      module.exports = {\n        root: true,\n        env: { browser: true, node: true, es2021: true },\n        parser: '@typescript-eslint/parser',\n        parserOptions: { ecmaVersion: 'latest', sourceType: 'module', ecmaFeatures: { jsx: true } },\n        plugins: ['@typescript-eslint', 'react', 'react-hooks'],\n        extends: [\n          'eslint:recommended',\n          'plugin:@typescript-eslint/recommended',\n          'plugin:react/recommended',\n          'plugin:react-hooks/recommended',\n          'prettier'\n        ],\n        settings: { react: { version: 'detect' } },\n        rules: { 'react/react-in-jsx-scope': 'off' }\n      }\n   3. Create .prettierrc.json:\n      { \"semi\": true, \"singleQuote\": true, \"printWidth\": 100, \"trailingComma\": \"es5\" }\n   4. Add .prettierignore and .eslintignore (e.g., dist, out, build, node_modules).\n\n9) Package Scripts (dev, build, lint, format)\n   1. In package.json, ensure the following scripts exist/are adjusted:\n      - \"dev\": \"electron-vite dev\"\n      - \"build\": \"electron-vite build && electron-builder\"\n      - \"lint\": \"eslint . --ext .ts,.tsx,.cjs,.mjs\"\n      - \"format\": \"prettier --write .\"\n   2. Keep \"type\": \"module\" if template uses ESM.\n\n10) Electron Builder Configuration\n   1. Add a minimal build config in package.json or electron-builder.yml:\n      - appId: com.yourorg.factory-local-app\n      - productName: Factory Local App\n      - files: [\"dist/**\", \"dist-electron/**\", \"package.json\"] (paths may differ depending on template output)\n      - directories: { output: \"release\" }\n      - mac/win/linux targets: use defaults (e.g., dmg, nsis, AppImage) or minimal cross-platform.\n   2. Ensure electron-builder is a devDependency (template usually includes it).\n\n11) Content Security Policy (CSP)\n   1. In renderer index.html, add a conservative CSP meta for production:\n      - <meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; script-src 'self'; style-src 'self' 'unsafe-inline'; img-src 'self' data:; connect-src 'self'; object-src 'none'; base-uri 'self'; form-action 'self'\">\n   2. For development, allow Vite's websocket: include ws://localhost:* in connect-src when NODE_ENV=development.\n\n12) Test Dev Workflow\n   1. Run: pnpm dev (or npm run dev)\n   2. Verify the Electron window loads the React app, shows versions, and the ping button returns \"pong\".\n   3. Confirm DevTools are available in dev and disabled in production builds.\n\n13) Test Production Build\n   1. Run: pnpm build (or npm run build)\n   2. Verify artifacts are generated in release/ (or dist/ depending on template).\n   3. Launch the packaged app to confirm it runs and shows the placeholder UI.\n\n14) Documentation\n   1. Create/Update README.md with:\n      - Prerequisites\n      - Install steps\n      - Scripts (dev, build, lint, format)\n      - Security defaults explanation (contextIsolation, sandbox, nodeIntegration=false, CSP)\n      - Known paths for main/preload/renderer code\n   2. Note how to switch between npm and pnpm.\n\nAcceptance Checklist Mapping\n- Run pnpm/npm run dev: opens Electron with React UI placeholder and working preload IPC (ping).\n- Run pnpm/npm run build: produces a runnable packaged app.\n- TypeScript config present (root and/or per package) with strict.\n- ESLint + Prettier configured with scripts lint and format.\n- Secure defaults in BrowserWindow: contextIsolation=true, sandbox=true, nodeIntegration=false; preload used; renderer sandboxed.\n- Separate code packages for main, preload, renderer via electron-vite template.",
      "context": [],
      "acceptance": []
    },
    {
      "id": "5.3",
      "status": "-",
      "title": "Typed IPC contract and preload API surface",
      "description": "Define a minimal IPC contract with typed channels for: settings:get/set, project:select/validate, tasks:list, task:get, task:update, docs:list, docs:read, git:status, agents:list/start/stop/logs, llm:chat. Implement a preload script exposing a narrow, typed API to the renderer. Document IPC schemas in docs/ARCHITECTURE.md. Acceptance: TypeScript types for request/response payloads; runtime validation; renderer can call stubs for each channel; security validated (no Node APIs exposed directly).",
      "plan": "Typed IPC contract and preload API surface \u2013 Implementation Plan\n\nGoal\nProvide a minimal, secure IPC contract with typed channels and runtime validation. Expose a narrow, typed preload API to the renderer. Include documentation and basic tests. Ensure no Node APIs are exposed.\n\nTech choices\n- Language: TypeScript\n- Validation: zod\n- Electron APIs: ipcMain.handle / ipcRenderer.invoke, contextBridge.exposeInMainWorld\n- Testing: vitest (or jest) for unit tests\n\n1) Repository structure and dependencies\n1.1. Create/confirm project structure:\n- /electron/main/ (main process TS)\n- /electron/preload/ (preload TS)\n- /shared/ipc/ (shared channel names, schemas, types)\n- /renderer/ (React code)\n- /docs/ARCHITECTURE.md (IPC contract docs)\n- /tests/ (unit tests for schemas and preload surface)\n1.2. Add dependencies:\n- dependencies: zod\n- devDependencies: @types/electron, vitest (or jest), ts-node/tsup/esbuild as needed for build, typescript\n1.3. Ensure tsconfig is split or configured for main/preload/renderer with isolatedModules.\n\n2) Define channel names and IPC versioning\n2.1. Create shared/ipc/channels.ts:\n- export const IPC_VERSION = 'v1' as const\n- export const Channels = {\n  settings: { get: 'settings:get', set: 'settings:set' },\n  project: { select: 'project:select', validate: 'project:validate' },\n  tasks: { list: 'tasks:list', get: 'task:get', update: 'task:update' },\n  docs: { list: 'docs:list', read: 'docs:read' },\n  git: { status: 'git:status' },\n  agents: { list: 'agents:list', start: 'agents:start', stop: 'agents:stop', logs: 'agents:logs' },\n  llm: { chat: 'llm:chat' },\n  meta: { version: 'ipc:version' }\n} as const\n- export type ChannelName = typeof Channels[keyof typeof Channels][keyof typeof Channels[keyof typeof Channels]]; (or flatten into a union)\n\n3) Define runtime schemas and types\n3.1. Create shared/ipc/schemas.ts using zod. For each channel define request/response schemas:\n- settings:get\n  Req: z.object({ keys: z.array(z.string()).optional() })\n  Res: z.object({ values: z.record(z.unknown()) })\n- settings:set\n  Req: z.object({ values: z.record(z.unknown()) })\n  Res: z.object({ success: z.boolean() })\n- project:select\n  Req: z.object({ path: z.string() })\n  Res: z.object({ path: z.string(), name: z.string().optional(), valid: z.boolean() })\n- project:validate\n  Req: z.object({ path: z.string() })\n  Res: z.object({ valid: z.boolean(), reasons: z.array(z.string()).optional() })\n- tasks:list\n  Req: z.object({ status: z.array(z.string()).optional(), search: z.string().optional(), limit: z.number().int().min(1).max(500).optional() })\n  Res: z.object({ tasks: z.array(z.object({ id: z.string(), title: z.string(), status: z.string(), assignee: z.string().nullable().optional(), updatedAt: z.string() })) })\n- task:get\n  Req: z.object({ id: z.string() })\n  Res: z.object({ id: z.string(), title: z.string(), description: z.string().optional(), status: z.string(), notes: z.string().optional(), metadata: z.record(z.unknown()).optional(), updatedAt: z.string() })\n- task:update\n  Req: z.object({ id: z.string(), patch: z.object({ title: z.string().optional(), description: z.string().optional(), status: z.string().optional(), notes: z.string().optional(), metadata: z.record(z.unknown()).optional() }).refine((p)=>Object.keys(p).length>0, 'patch must have at least 1 key') })\n  Res: z.object({ success: z.boolean(), task: z.any().optional() })\n- docs:list\n  Req: z.object({ basePath: z.string().optional() })\n  Res: z.object({ docs: z.array(z.object({ path: z.string(), title: z.string().optional() })) })\n- docs:read\n  Req: z.object({ path: z.string() })\n  Res: z.object({ path: z.string(), content: z.string(), frontmatter: z.record(z.unknown()).optional() })\n- git:status\n  Req: z.object({ cwd: z.string().optional() })\n  Res: z.object({ branch: z.string().optional(), dirty: z.boolean(), ahead: z.number().int().optional(), behind: z.number().int().optional(), files: z.array(z.object({ path: z.string(), status: z.string() })) })\n- agents:list\n  Req: z.object({})\n  Res: z.object({ agents: z.array(z.object({ id: z.string(), name: z.string(), status: z.enum(['idle','running','stopped','error']), pid: z.number().optional(), taskId: z.string().optional() })) })\n- agents:start\n  Req: z.object({ id: z.string().optional(), name: z.string().optional(), args: z.record(z.unknown()).optional() }).refine((v)=>!!v.id||!!v.name, { message: 'id or name required' })\n  Res: z.object({ success: z.boolean(), instanceId: z.string().optional() })\n- agents:stop\n  Req: z.object({ id: z.string() })\n  Res: z.object({ success: z.boolean() })\n- agents:logs\n  Req: z.object({ id: z.string(), since: z.number().int().optional(), limit: z.number().int().optional() })\n  Res: z.object({ logs: z.array(z.object({ ts: z.number(), level: z.enum(['debug','info','warn','error']), message: z.string() })) })\n- llm:chat\n  Req: z.object({ model: z.string().optional(), messages: z.array(z.object({ role: z.enum(['system','user','assistant','tool']), content: z.string(), name: z.string().optional(), tool_call_id: z.string().optional() })), temperature: z.number().min(0).max(2).optional() })\n  Res: z.object({ message: z.object({ role: z.literal('assistant'), content: z.string() }), usage: z.object({ promptTokens: z.number().optional(), completionTokens: z.number().optional() }).optional() })\n- meta: version\n  Req: z.object({}) ; Res: z.object({ version: z.string() })\n3.2. Create shared/ipc/types.ts exporting TypeScript types via zod.infer for all request/response payloads (e.g., SettingsGetReq = z.infer<typeof Schemas.Settings.Get.Req>) and grouped namespaces.\n\n4) Main-process: typed handler registration with runtime validation\n4.1. Create electron/main/ipc/handle.ts with helper:\n- function registerHandler<TReq, TRes>(channel: string, reqSchema: ZodSchema<TReq>, resSchema: ZodSchema<TRes>, handler: (event, req: TReq) => Promise<TRes> | TRes)\n  - ipcMain.handle(channel, async (event, raw) => { const req = reqSchema.parse(raw); const res = await handler(event, req); return resSchema.parse(res); })\n4.2. Create electron/main/ipc/register.ts to register all channels with stub handlers:\n- settings:get -> in-memory store (Map) returning requested keys or all\n- settings:set -> merge into Map, return { success: true }\n- project:select -> return { path, name: basename(path), valid: true }\n- project:validate -> return { valid: true, reasons: [] }\n- tasks:list -> return { tasks: [] } (stub)\n- task:get -> return a fabricated task for given id\n- task:update -> noop update against fabricated task; return { success: true, task: { ... } }\n- docs:list -> return { docs: [{ path: 'README.md', title: 'README' }] }\n- docs:read -> return content stub like '# Placeholder'\n- git:status -> return { dirty: false, files: [], branch: 'main', ahead: 0, behind: 0 }\n- agents:list -> return an empty list\n- agents:start -> return { success: true, instanceId: 'stub-1' }\n- agents:stop -> return { success: true }\n- agents:logs -> return { logs: [] }\n- llm:chat -> return { message: { role: 'assistant', content: 'Stub response' } }\n- ipc:version -> return { version: IPC_VERSION }\n4.3. Wire registration in electron/main/index.ts after app.whenReady():\n- import registerIPCHandlers() and call it before creating BrowserWindow\n\n5) Preload: secure, narrow, typed API surface\n5.1. Create electron/preload/safeInvoke.ts\n- function safeInvoke<TReq, TRes>(channel, reqSchema, resSchema, payload):\n  - validate payload with reqSchema.parse\n  - const res = await ipcRenderer.invoke(channel, payload)\n  - return resSchema.parse(res)\n5.2. Create electron/preload/index.ts\n- Use contextBridge.exposeInMainWorld('api', {\n  meta: { version: () => safeInvoke(Channels.meta.version, Schemas.Meta.Version.Req, Schemas.Meta.Version.Res, {}) },\n  settings: { get: (keys?) => safeInvoke(...), set: (values) => safeInvoke(...) },\n  project: { select: (path) => safeInvoke(...), validate: (path) => safeInvoke(...) },\n  tasks: { list: (opts?) => safeInvoke(...), get: (id) => safeInvoke(...), update: (id, patch) => safeInvoke(...) },\n  docs: { list: (basePath?) => safeInvoke(...), read: (path) => safeInvoke(...) },\n  git: { status: (cwd?) => safeInvoke(...) },\n  agents: { list: () => safeInvoke(...), start: (args) => safeInvoke(...), stop: (id) => safeInvoke(...), logs: (id, opts?) => safeInvoke(...) },\n  llm: { chat: (input) => safeInvoke(...) }\n})\n5.3. Add electron/preload/global.d.ts to augment Window:\n- declare global { interface Window { api: { ...full typed surface... } } }\n5.4. Ensure no Node APIs are exposed; do not export ipcRenderer or fs. Only functions above.\n\n6) BrowserWindow security hardening\n6.1. In electron/main/createWindow.ts (or index.ts) when creating BrowserWindow:\n- webPreferences: {\n  contextIsolation: true,\n  nodeIntegration: false,\n  enableRemoteModule: false,\n  sandbox: true,\n  preload: path.join(__dirname, 'preload.js'),\n}\n- Set a Content Security Policy for the renderer (meta tag or headers if using custom protocol). Disallow eval.\n- Validate allowed origins if loading external content (prefer file:// or custom app:// protocol only).\n\n7) Renderer stubs/smoke wiring\n7.1. In renderer, create a simple hook or effect that calls window.api.meta.version() and window.api.tasks.list() and logs results to ensure stubs function.\n7.2. Add minimal UI trigger (button) to call, but feature acceptance only requires renderer can call stubs; the hook suffices.\n\n8) Tests\n8.1. Schema tests (tests/ipc.schemas.test.ts):\n- For each Req/Res schema, test valid payload passes and representative invalid payload fails.\n8.2. Preload API surface tests (tests/preload.api.test.ts):\n- Mock ipcRenderer.invoke and assert safeInvoke parses/throws correctly.\n- Assert window.api exposes only expected top-level keys (Object.keys(window.api)).\n8.3. Handler tests (tests/main.handlers.test.ts):\n- Unit test registerHandler rejects invalid requests and validates responses.\n\n9) Documentation\n9.1. Create/extend docs/ARCHITECTURE.md with:\n- IPC overview: goals, security model, versioning (IPC_VERSION = v1), channel naming conventions, request/response flow.\n- Channel catalog: list each channel with request/response shape (brief tables or bullet lists), example payloads, error semantics (Zod errors mapped to { code: 'BAD_REQUEST', message }).\n- Preload API surface: document window.api structure and usage examples.\n- Security posture: contextIsolation, nodeIntegration=false, no Node exposure, runtime validation, CSP.\n- Extensibility: how to add a new channel (add schemas, types, handler, preload function, docs), versioning strategy (introduce v2 channels or feature-detect via ipc:version).\n\n10) DX and linting safeguards\n10.1. Add ESLint/TS rules to prevent importing 'electron' or Node built-ins in /renderer.\n10.2. Add tsconfig path aliases: '@shared/*' -> './shared/*' to share types.\n10.3. Add a precommit hook to run type check and tests for IPC layers.\n\n11) Acceptance validation checklist\n- TypeScript types exported for all request/response payloads under shared/ipc/types.ts\n- All ipcMain handlers and preload wrappers validate with zod at runtime\n- Renderer can call stubs for each channel: add a simple smoke call on app start\n- Security validated: BrowserWindow uses contextIsolation, nodeIntegration=false, sandbox=true; preload exposes only window.api; no direct Node APIs accessible in renderer\n\n12) Future work hooks (non-blocking)\n- Swap stub handlers with real integrations (git CLI, agents orchestrator, docs FS)\n- Introduce structured error type and map zod errors to renderer-friendly error codes\n- Add streaming support for llm:chat (via ipc event or MessagePort)\n- Add permissions model to restrict llm:chat to read-only tools\n",
      "context": [],
      "acceptance": []
    },
    {
      "id": "5.4",
      "status": "-",
      "title": "Local settings storage and project root selector",
      "description": "Implement a JSON-backed settings store in Electron userData path. Create UI to set and persist the path to the factory project root. Implement project validation against docs/FILE_ORGANISATION.md (check tasks/, docs/, scripts/, etc.). Acceptance: User can pick a folder; app validates and persists; invalid structure yields clear error; settings survive restarts; tested on macOS/Windows/Linux paths.",
      "plan": "Title: Local settings storage and project root selector (Electron + React)\n\nGoal\n- Persist user settings (JSON) in Electron app.getPath('userData')\n- Provide UI to pick and persist the factory project root directory\n- Validate the selected project directory against required structure (including docs/FILE_ORGANISATION.md and key folders like tasks/, docs/, scripts/)\n- Show clear errors for invalid selections\n- Ensure settings survive restarts\n- Work on macOS, Windows, Linux\n\nHigh-level Architecture\n- Main process: SettingsStore (JSON on disk), ProjectValidator (filesystem checks), IPC handlers for settings and validation\n- Preload: Expose a minimal, typed API via contextBridge\n- Renderer: Settings UI (React) to view/change project root, invoke validation, and show status\n- Shared types: TS interfaces for Settings and ValidationResult used across boundaries\n\nStep-by-step Plan\n1) Define shared types\n   - Create src/shared/types.ts:\n     - export interface AppSettings { version: number; projectRootPath?: string; lastValidatedAt?: string; }\n     - export interface ValidationIssue { code: string; message: string; path?: string; }\n     - export interface ValidationResult { ok: boolean; issues: ValidationIssue[]; }\n\n2) Implement SettingsStore in main\n   - File: src/main/settings/SettingsStore.ts\n   - Responsibilities:\n     - Use app.getPath('userData') to determine settings path (e.g., settings.json)\n     - Load on construction; if file missing, start with defaults { version: 1 }\n     - Provide async get(): Promise<AppSettings>\n     - Provide async set(patch: Partial<AppSettings>): Promise<AppSettings>\n     - Atomic write approach: write to temp file then rename, or writeFile with fs.promises; include try/catch and fallback\n     - Validate JSON on read; if corrupted, back up to settings.bak-<timestamp>.json and reset to defaults\n     - Normalize stored paths (use path.resolve and path.normalize), preserve original case on Windows but normalize separators in logic\n     - Export a singleton instance\n\n3) Implement ProjectValidator in main\n   - File: src/main/validation/ProjectValidator.ts\n   - validate(path: string): Promise<ValidationResult>\n     - Steps:\n       a) Resolve and realpath the provided path; ensure it exists and is a directory -> else issues.push({ code: 'NOT_A_DIRECTORY', ... })\n       b) Check required items:\n          - docs/FILE_ORGANISATION.md exists\n          - tasks/ directory exists\n          - docs/ directory exists\n          - scripts/ directory exists\n       c) Optional checks (non-blocking warnings): .git exists; README.md exists\n       d) If docs/FILE_ORGANISATION.md exists, optionally parse for additional expected paths:\n          - Simple heuristic: scan for backticked paths or lines starting with - or * that contain folder names; for each \"path/\" token, check existence; add issues with code 'MISSING_FROM_DOCS_SPEC' if missing (as warning)\n       e) Accumulate issues; ok = issues with blocking codes length === 0\n       f) Return { ok, issues }\n     - Cross-platform notes: use path.join; avoid hard-coded separators; handle permissions by catching EACCES and reporting code 'PERMISSION_DENIED'\n\n4) IPC contract and handlers (main)\n   - File: src/main/ipc/settingsIpc.ts\n   - Register in app ready phase\n   - ipcMain.handle('settings:get', async () => SettingsStore.get())\n   - ipcMain.handle('settings:setProjectRoot', async (event, folderPath: string) => {\n       const result = await ProjectValidator.validate(folderPath)\n       if (!result.ok) return { ok: false, result }\n       const settings = await SettingsStore.set({ projectRootPath: path.resolve(folderPath), lastValidatedAt: new Date().toISOString() })\n       return { ok: true, settings, result }\n     })\n   - ipcMain.handle('settings:validateProjectRoot', async (event, folderPath: string) => {\n       return await ProjectValidator.validate(folderPath)\n     })\n\n5) Preload bridge\n   - File: src/preload/index.ts\n   - contextIsolation: true, nodeIntegration: false\n   - Expose api.settings with types:\n     - get(): Promise<AppSettings>\n     - setProjectRoot(path: string): Promise<{ ok: boolean; settings?: AppSettings; result: ValidationResult }>\n     - validateProjectRoot(path: string): Promise<ValidationResult>\n   - Use ipcRenderer.invoke for the above channels\n\n6) Renderer: Settings UI\n   - Files:\n     - src/renderer/pages/Settings.tsx\n     - src/renderer/components/FolderPicker.tsx\n   - Settings.tsx features:\n     - Load current settings on mount (api.settings.get)\n     - Show current projectRootPath (read-only field or text)\n     - Input + \"Browse\" button to open folder dialog (via a small main-side helper or use ipcRenderer.invoke('dialog:openDirectory'))\n       - Add a minimal dialog handler in main: ipcMain.handle('dialog:openDirectory', async () => dialog.showOpenDialog({ properties: ['openDirectory'] }))\n     - Validate button: calls api.settings.validateProjectRoot(path)\n     - Save button: calls api.settings.setProjectRoot(path)\n     - Status area:\n       - If validation ok: green success message\n       - If invalid: list issues with clear messages and codes; group blocking vs warnings\n     - Clear/Reset button: let user clear projectRootPath (api.settings.setProjectRoot('')) or add 'settings:clear' handler to remove the key\n   - FolderPicker.tsx: simple component with input and Browse button\n\n7) App startup behavior\n   - In main app ready:\n     - Load settings; if no projectRootPath or validation fails (validate on startup), consider presenting a modal or route to Settings page in renderer\n   - In renderer root, if settings.projectRootPath missing or invalid, redirect to Settings route\n\n8) Error handling and messaging\n   - Translate ValidationIssue codes to user-friendly text in UI:\n     - NOT_A_DIRECTORY: \"Selected path is not a directory or does not exist\"\n     - MISSING_FILE_ORGANISATION: \"Missing docs/FILE_ORGANISATION.md\"\n     - MISSING_TASKS_DIR: \"Missing tasks/ folder\"\n     - MISSING_DOCS_DIR: \"Missing docs/ folder\"\n     - MISSING_SCRIPTS_DIR: \"Missing scripts/ folder\"\n     - PERMISSION_DENIED: \"Insufficient permissions to read this path\"\n     - MISSING_FROM_DOCS_SPEC: \"Path referenced in FILE_ORGANISATION.md not found\"\n   - The API returns structured issues; the UI shows them clearly\n\n9) Cross-platform considerations\n   - Use path.join and fs.promises\n   - Avoid shell expansions; always resolve absolute paths\n   - Windows: handle drive letters; do not alter case; store as returned by dialog\n   - Linux/macOS: follow symlinks via fs.realpath; but store the user-chosen path and keep resolved path only for internal checks\n   - Dialog filters: none (directory only)\n\n10) Persistence verification\n   - Ensure settings.json written to app.getPath('userData')\n   - On restart, SettingsStore loads existing file and hydrates state\n   - Add logging in dev for load/save paths\n\n11) Testing\n   - Unit tests (Node/Vitest or Jest) for ProjectValidator:\n     - Valid structure returns ok=true\n     - Missing tasks/ -> blocking issue\n     - Missing docs/FILE_ORGANISATION.md -> blocking issue\n     - Permission denied (simulate by pointing to a restricted dir) -> PERMISSION_DENIED\n     - Cross-platform path normalization tests (use path.normalize) and mock fs where needed\n   - Manual E2E checks on macOS/Windows/Linux:\n     - Pick valid project root -> success and persisted across app restart\n     - Pick invalid folder -> clear errors shown, not persisted\n     - After save, restart app -> settings loaded, UI shows selected path\n\n12) Implementation details and scaffolding\n   - Add new scripts/entries:\n     - Ensure preload is configured in BrowserWindow({ webPreferences: { preload, contextIsolation: true, nodeIntegration: false } })\n   - Update TypeScript config to include src/shared in both main and renderer tsconfig references\n   - Add minimal logging facility for main (console in dev)\n\n13) Documentation\n   - Add docs/settings.md explaining persistence location per OS, what is validated, and troubleshooting common errors\n   - Update README to describe how to configure project root in the app\n\n14) Acceptance criteria mapping\n   - User can pick a folder: Settings UI with folder dialog\n   - App validates and persists: 'Validate' and 'Save' flows wire to ProjectValidator and SettingsStore\n   - Invalid structure yields clear error: ValidationIssue codes/messages shown in UI\n   - Settings survive restarts: stored in userData/settings.json and loaded on launch\n   - Tested on macOS/Windows/Linux: unit tests + manual steps documented\n\n15) Nice-to-haves (deferred if time-limited)\n   - Live watcher: revalidate when project structure changes\n   - Auto-detect probable project root by scanning parent folders for matching structure\n   - Migration system for settings.version\n",
      "context": [],
      "acceptance": []
    },
    {
      "id": "5.5",
      "status": "-",
      "title": "Task schema definition and validator",
      "description": "Create a JSON Schema that mirrors the canonical task format described in docs/tasks/task_format.py and task_example.json. Generate TypeScript interfaces from the schema. Implement a validator used before reading/writing task.json. Acceptance: Validator catches malformed examples; TS types aligned with schema; unit tests cover valid/invalid cases using sample task.json files.",
      "plan": "Implementation plan for Feature 5.5: Task schema definition and validator\n\n1) Gather canonical sources\n- Open and study docs/tasks/task_format.py and docs/tasks/task_example.json to enumerate all fields, types, required/optional properties, allowed enums, nested objects/arrays, defaults, and any constraints (e.g., regex patterns, value ranges, cross-field rules).\n- Document the final field list and constraints in a short design notes file at docs/tasks/schema_notes.md for future maintainability.\n\n2) Create JSON Schema\n- File: schema/task.schema.json\n- Version: Draft 2020-12 (or 2019-09) to support modern features. Include $schema and $id.\n- Define the root object type with strict: \"additionalProperties\": false\n- Encode all required fields from Python canonical format.\n- Capture enums, min/max constraints, formats (date-time, uri), and patterns as present in the canonical spec.\n- Use definitions/$defs for reusable sub-objects (e.g., Task, Subtask, Assignee, StatusHistory, Link, etc.) if applicable.\n- Provide description fields for clarity and align property naming exactly with canonical names.\n- If Python spec defines defaults, include them using default where helpful (note defaults are for tooling, not enforcement).\n- Add examples array containing the known-good task_example.json.\n\n3) Validation library setup (Node/TS)\n- Dependency: ajv@^8 and ajv-formats for formats support.\n- Create a validation module in shared code:\n  - File: src/shared/validation/taskValidator.ts\n  - Export: validateTask(data: unknown): { valid: true; data: Task } | { valid: false; errors: Ajv.ErrorObject[] }\n  - Load and compile the schema once (singleton), configure Ajv with:\n    - allErrors: true\n    - strict: true\n    - removeAdditional: false\n    - allowUnionTypes: true (if needed)\n    - formats from ajv-formats\n  - Add helper function assertValidTask(data) that throws a descriptive Error when invalid, with a compacted error message builder for UI logging.\n\n4) Type generation from schema\n- Dependency: json-schema-to-typescript (jstt).\n- Script: npm run generate:task-types -> generates src/shared/types/task.ts from schema/task.schema.json\n- Configure jstt options:\n  - bannerComment warning that the file is auto-generated, do not edit.\n  - style: prefer interfaces\n  - declareExternallyReferenced: true\n- Ensure the generated root type is exported as Task to be consumed across the app.\n- Add a type-test compile step (tsc --noEmit) in CI that imports Task from generated types and uses it in at least one file to ensure alignment.\n\n5) Integrate validator in read/write flows\n- Identify modules that read and write task.json (e.g., src/main/fs/taskStore.ts or equivalent). If they don\u2019t exist yet, create a dedicated task store module.\n- On read:\n  - Read JSON -> parse -> validate via validateTask\n  - If invalid: throw a descriptive error including path(s) and message(s) for UI display.\n  - If valid: return typed Task\n- On write:\n  - Validate the Task object before serialization. If invalid, fail-fast with error to avoid persisting malformed data.\n- Optional: provide a CLI/Dev script npm run validate:task path/to/task.json to quickly validate files during development.\n\n6) Testing\n- Test framework: Vitest (or Jest if the project standard already exists). Assume Vitest here.\n- Add fixtures:\n  - tests/fixtures/task/valid/task_valid.json \u2014 copy of docs/tasks/task_example.json\n  - tests/fixtures/task/invalid/*.json \u2014 multiple malformed cases, such as:\n    - missing required field(s)\n    - wrong type (string vs number)\n    - disallowed additional properties\n    - invalid enum values\n    - invalid nested object shape\n    - bad format (e.g., invalid date-time)\n- Unit tests:\n  - tests/taskValidator.valid.spec.ts \u2014 ensure valid example passes and types narrow to Task\n  - tests/taskValidator.invalid.spec.ts \u2014 iterate over invalid fixtures, assert validateTask returns {valid:false} and errors describe the failing paths\n  - tests/generation.types.spec.ts \u2014 import generated Task type and ensure a sample object typed as Task compiles; ensure a known-invalid object fails type-check via // @ts-expect-error tests\n- Ensure CI runs: type generation (or validate generated file is up-to-date), tsc --noEmit, and vitest\n\n7) Developer tooling and scripts\n- package.json scripts:\n  - generate:task-types: json2ts schema/task.schema.json -o src/shared/types/task.ts\n  - validate:task: ts-node scripts/validateTaskFile.ts <path> (or node + tsx if repo uses it)\n  - test: vitest run\n  - typecheck: tsc --noEmit\n- Add a prebuild or postinstall step to generate types or document that contributors must run generate:task-types after schema changes.\n\n8) Documentation\n- docs/tasks/schema_notes.md \u2014 mapping table: Python canonical fields -> JSON Schema properties; any assumptions; examples of valid/invalid fragments.\n- CONTRIBUTING.md \u2014 add a short section explaining how to modify task.schema.json, regenerate types, run validator, and add tests.\n\n9) Quality gates\n- Add a CI job that fails if:\n  - Generated types are outdated (diff check after running generate:task-types)\n  - tsc typecheck fails\n  - vitest fails\n- Add a pre-commit hook (optional) using simple-git-hooks or husky to run quick validate:task on changed task.json files.\n\n10) Future-proofing\n- If the Python canonical spec evolves, keep a bi-directional mapping note in schema_notes.md and bump schema $id version (e.g., v1 -> v1.1). Communicate breaking vs non-breaking changes and update tests accordingly.\n\nDeliverables checklist\n- schema/task.schema.json aligned with docs/tasks/task_format.py and task_example.json\n- src/shared/types/task.ts generated by json-schema-to-typescript\n- src/shared/validation/taskValidator.ts with Ajv-based validateTask/assertValidTask\n- Read/write integration with validation hooks\n- Tests and fixtures for valid/invalid cases\n- Scripts in package.json and CI updates\n- Documentation updates",
      "context": [],
      "acceptance": []
    },
    {
      "id": "5.6",
      "status": "-",
      "title": "Tasks indexer and file watcher",
      "description": "Scan tasks/{id}/ directories under the selected project root to build an in-memory index of tasks and features. Implement a file watcher to refresh the index on changes (create/modify/delete). Cache results for quick UI rendering. Acceptance: Indexing handles 100+ tasks; watcher reliably updates on file changes; performance measured and documented; exposed via IPC: tasks:list and task:get.",
      "plan": "Title: Tasks indexer and file watcher\n\nGoal\n- Scan tasks/{id}/ under the selected project root to build an in-memory index of tasks and their features.\n- Implement a file watcher to refresh the index on filesystem changes (create/modify/delete).\n- Cache results for fast UI rendering.\n- Expose IPC endpoints: tasks:list and task:get.\n- Handle 100+ tasks reliably; measure and document performance.\n\nHigh-level Design\n- Run the indexer in Electron main process.\n- Use chokidar to watch the tasks directory.\n- In-memory cache for fast list rendering; optionally persist to disk to prewarm on app start.\n- Minimal summaries for list; full details on demand for get.\n- Parser abstraction to support JSON/YAML task metadata (task.json/task.yaml). Extract features if present.\n- IPC handlers return typed DTOs to the renderer.\n\nDirectory and Files\n- tasks/{id}/ is a task directory. We detect the task ID from the directory name.\n- Preferred task metadata files within each task dir (first match wins):\n  1) task.json\n  2) task.yaml or task.yml\n  3) README.md (fallback for title/description only)\n- Optional files: features.json or features.yaml; otherwise features can live inline in task metadata under \"features\" key. If none found, features = []\n\nTech Stack\n- Node/Electron main process (TypeScript)\n- chokidar for watching\n- fast-glob for initial discovery (or fs.readdir recursive if preferred)\n- yaml for YAML parsing\n- fs-extra for FS convenience\n- zod for schema validation (optional but recommended)\n- lodash.debounce (or simple custom debounce)\n- perf_hooks for measurements\n- Jest or Vitest for tests\n\nType Definitions (shared/types/tasks.ts)\n- TaskId = string\n- TaskSummary {\n  id: string\n  path: string\n  title: string\n  status?: string\n  featureCount: number\n  updatedAt: number // ms epoch from latest relevant file mtime\n}\n- TaskFeature {\n  id: string\n  title?: string\n  status?: string\n}\n- TaskDetail extends TaskSummary {\n  description?: string\n  assignee?: string\n  tags?: string[]\n  features: TaskFeature[]\n  raw?: { source: 'json'|'yaml'|'md'|null, data?: any }\n}\n- TaskIndexStats {\n  projectRoot: string\n  taskCount: number\n  lastFullScanMs: number\n  lastScanAt: number\n  averageScanMs?: number\n}\n\nFilesystem Parsing Rules\n- For each tasks/<id>/:\n  - Read task.json or task.yaml/yml. Validate with zod schema (soft validation: log and continue if invalid).\n  - Extract fields: title, status, description, assignee, tags, features.\n  - If features missing, try features.json or features.yaml.\n  - If no structured metadata found, try README.md: use first heading as title and first paragraph as description; features = [].\n  - Determine updatedAt as max mtime of the selected primary metadata file and features file (if any).\n- Feature entries should at least have id; if no id provided, derive from directory/file name or hash of title.\n\nCaching Strategy\n- Maintain an in-memory Map<string, TaskDetail> index (key = taskId).\n- Maintain a separate array of TaskSummary built from details to respond quickly.\n- Persist a snapshot of summaries + a minimal detail cache to disk in app.getPath('userData')/cache/tasks/<hash(projectRoot)>.json to prewarm on app launch.\n- On startup for a given project root: try load disk cache first, serve immediately; then trigger background fresh full scan to validate/refresh.\n- Throttle disk cache writes (e.g., once every 2 seconds, trailing) to avoid excessive FS writes during rapid changes.\n\nWatcher Strategy (chokidar)\n- Watch: <projectRoot>/tasks/** with ignored patterns: ['**/node_modules/**', '**/.git/**', '**/.DS_Store'].\n- Events handled: add, addDir, change, unlink, unlinkDir.\n- Debounce re-scan operations per task directory (e.g., 150ms) to coalesce multiple rapid edits.\n- Incremental updates: on event within tasks/<id>/..., only re-parse that specific task; on directory removal, delete entry; on new dir, parse it.\n- Provide a full re-scan method as fallback and for initial indexing.\n\nPerformance\n- Use perf_hooks.performance.now() around scan operations; record lastFullScanMs and average over recent N scans.\n- Target: 100+ tasks initial scan in under ~500ms for simple metadata on a typical dev machine (document test conditions).\n- Ensure watchers do not trigger full re-scan unless necessary; prefer per-task incremental updates.\n\nIPC Endpoints (main/ipc/tasks.ts)\n- tasks:list -> returns { tasks: TaskSummary[], stats: TaskIndexStats }\n- task:get { id: string } -> returns TaskDetail | null\n- Optionally (dev-only): tasks:stats -> TaskIndexStats (or included in tasks:list)\n\nAPI Contracts (renderer expectation)\n- tasks:list should resolve quickly using in-memory summaries, even if a background refresh is ongoing.\n- task:get should return from cache if available; otherwise parse on-demand for that task directory and update cache.\n\nEdge Cases & Error Handling\n- Missing or malformed metadata: log warning; fall back to minimal info from directory name; do not crash.\n- Duplicate task IDs (duplicate directory names): last write wins; log error.\n- Non-UTF8 files: ignore with warning.\n- Root change: gracefully dispose current watcher and caches; initialize new indexer.\n\nImplementation Steps\n1) Scaffolding\n   - Create files:\n     - main/services/tasks/TaskIndexer.ts\n     - main/services/tasks/parsers/jsonParser.ts\n     - main/services/tasks/parsers/yamlParser.ts\n     - main/services/tasks/parsers/mdParser.ts\n     - main/ipc/tasks.ts\n     - shared/types/tasks.ts\n     - docs/performance/tasks_indexer.md\n     - tests/tasks/indexer.spec.ts\n\n2) Types and Schemas\n   - Define TaskSummary, TaskDetail, TaskFeature, TaskIndexStats in shared/types/tasks.ts.\n   - Define zod schemas in parsers for validation (optional but helpful).\n\n3) Parsers\n   - jsonParser: read task.json/features.json; parse, validate, normalize fields.\n   - yamlParser: read task.yaml|yml/features.yaml|yml; parse with yaml.\n   - mdParser: read README.md; extract first H1 (title) and first paragraph (description).\n   - Export a function parseTaskDir(taskDir: string): Promise<TaskDetail | null> that tries parsers in order and returns normalized TaskDetail.\n   - Ensure updatedAt is computed via fs.stat for the chosen files.\n\n4) TaskIndexer Class (main/services/tasks/TaskIndexer.ts)\n   - constructor(projectRoot: string)\n   - public async init(): initializes cache (load from disk), sets up chokidar watcher, triggers initial full scan in background.\n   - private async fullScan():\n     - Enumerate subdirectories under <root>/tasks using fs or fast-glob.\n     - In parallel (bounded concurrency, e.g., 10), parse each task dir.\n     - Build memory maps for details and summaries; compute stats; swap atomically.\n     - Persist summaries to disk cache (throttled).\n   - private async parseAndUpdateTask(taskDir: string): parse single task and update/remove in cache.\n   - private onFsEvent(event, path): debounced per task directory -> calls parseAndUpdateTask or remove.\n   - getSummaries(): TaskSummary[] (return shallow clone to avoid mutation)\n   - getTask(id: string): TaskDetail | null (if missing, try parse on-demand)\n   - getStats(): TaskIndexStats\n   - dispose(): close watcher, flush cache, cleanup timers.\n   - Use EventEmitter to emit 'index:updated' and 'task:updated' for future live UI updates (optional in this feature).\n\n5) Disk Cache\n   - Path: path.join(app.getPath('userData'), 'cache', 'tasks', hash(projectRoot) + '.json').\n   - Shape: { version: 1, projectRoot, summaries: TaskSummary[], timestamp }.\n   - Load on init if exists; populate in-memory summaries; mark as warm.\n   - Save after full scans and after bursts of incremental updates (throttled).\n\n6) Watcher Setup\n   - chokidar.watch(path.join(projectRoot, 'tasks'), { ignoreInitial: false, depth: 3, ignored: ['**/node_modules/**', '**/.git/**', '**/.DS_Store'] })\n   - Handle addDir/removeDir for tasks/<id> creation/deletion; add/change/unlink for metadata files inside.\n   - Debounce per-task using a Map<taskId, timeout> with 150ms delay.\n\n7) IPC Wiring (main/ipc/tasks.ts)\n   - Register handlers in app ready:\n     - ipcMain.handle('tasks:list', async () => ({ tasks: indexer.getSummaries(), stats: indexer.getStats() }))\n     - ipcMain.handle('task:get', async (_evt, id: string) => indexer.getTask(id))\n   - Export a function registerTasksIpc(indexer: TaskIndexer) to be called from main bootstrap.\n\n8) Bootstrap Integration\n   - In main process startup, when project root is selected/changed, instantiate TaskIndexer(root); call init(); registerTasksIpc(indexer).\n   - On root change, dispose previous indexer and create a new one.\n\n9) Performance Measurement & Documentation\n   - Record lastFullScanMs and taskCount on each scan; maintain an average over the last N scans.\n   - Add logs (debug) with counts and timings.\n   - Write docs/performance/tasks_indexer.md:\n     - How to run performance test\n     - Hardware/software environment\n     - Results for 100+ tasks (initial scan time, memory footprint estimate)\n\n10) Testing (Jest/Vitest)\n   - Create temp directory fixture with >120 tasks; generate task.json files with minimal fields.\n   - Test full scan finds all tasks and builds accurate summaries (featureCount, titles).\n   - Test watcher: create a new task dir -> expect new task in index after debounce; modify task.json title -> expect updated summary; delete task dir -> expect removal.\n   - Test performance: measure scan duration and assert within a reasonable bound (use generous threshold to avoid flakiness, but record measured value).\n   - Test malformed files: invalid JSON/YAML -> no crash, logs warning, task omitted or minimal fallback from README.md.\n   - Test disk cache: prewrite a cache file, init indexer, verify summaries served quickly prior to full scan.\n\n11) Observability & Logging\n   - Centralize logs in TaskIndexer with levels (info/debug/warn) using existing logging utility if present.\n   - Include counts and timings in info logs after scans.\n\n12) Configuration\n   - Expose optional configuration:\n     - TASKS_INDEXER_MAX_CONCURRENCY (default 10)\n     - TASKS_WATCH_DEBOUNCE_MS (default 150)\n     - TASKS_CACHE_WRITE_MS (default 2000)\n     - TASKS_DISABLE_DISK_CACHE (default false)\n   - Read from env or app config service.\n\n13) Security & Safety\n   - Sanitize and normalize projectRoot; ensure all watched paths are within projectRoot/tasks.\n   - Escape/sanitize IDs derived from directory names (use directory basename as ID, no path traversal).\n\n14) Acceptance Mapping\n- Indexing handles 100+ tasks: Verified by tests with 120+ generated tasks and documented timings.\n- Watcher reliably updates on file changes: Unit/integration tests simulate add/modify/delete and validate index updates.\n- Performance measured and documented: perf_hooks instrumentation and docs/performance report.\n- Exposed via IPC: tasks:list and task:get implemented and wired in main process.\n\n15) Future Enhancements (not required now)\n- Live push updates to renderer via IPC events on index changes.\n- Schema evolution handling with versioning.\n- Additional parsers (e.g., TOML) and richer feature directory structures.\n- Indexed search across task titles/descriptions via minisearch or lunr.\n",
      "context": [],
      "acceptance": []
    },
    {
      "id": "5.7",
      "status": "-",
      "title": "Tasks list UI with filtering and search",
      "description": "Build a React view listing tasks with id, title, status, and counts of features (done/total). Provide text search and filters (e.g., status). Clicking a row opens details. Acceptance: Renders list from IPC data; filtering/search applied client-side; empty states handled; accessibility basics (labels, keyboard nav) covered.",
      "plan": "Implementation Plan: Tasks list UI with filtering and search (Feature 5.7)\n\nAssumptions\n- Project uses Electron (main + preload) and React + TypeScript in renderer.\n- There is/will be an IPC surface to fetch tasks from the main process. If not present, we will add it here.\n- React Router is used (or can be added) for navigation to a Task Details view.\n\n1) Define shared types\n- Create shared/types/tasks.ts with the minimal shape required by this feature:\n  export type TaskStatus = 'todo' | 'in_progress' | 'blocked' | 'done'\n  export interface TaskSummary {\n    id: string\n    title: string\n    status: TaskStatus\n    features: { done: number; total: number }\n  }\n- If a shared folder is not available, duplicate the type in both main and renderer temporarily with TODO to consolidate.\n\n2) IPC: main process handlers\n- In main/src/ipc/tasks.ts (or similar):\n  - Register ipcMain.handle('tasks:get', async () => Promise<TaskSummary[]>)\n  - Implementation can read from the existing task source. If not available yet, stub with an in-memory mock returning an array of TaskSummary.\n- Export a small tasksService.listSummaries() to keep main code clean; later it can be wired to real data (git/agents).\n\n3) Preload bridge\n- In preload/index.ts, expose tasks API via contextBridge:\n  type TasksAPI = { getTasks: () => Promise<TaskSummary[]> }\n  contextBridge.exposeInMainWorld('tasksAPI', {\n    getTasks: () => ipcRenderer.invoke('tasks:get')\n  })\n- Add global typing for window.tasksAPI in renderer/src/types/global.d.ts to ensure TS safety.\n\n4) Renderer: API wrapper\n- Create renderer/src/api/tasks.ts:\n  export async function getTasks(): Promise<TaskSummary[]> { return window.tasksAPI.getTasks() }\n\n5) Routing: ensure details route exists\n- Add a route /tasks and /tasks/:id in the router if not already present.\n- Create a placeholder TaskDetailsPage that reads :id and displays basic info (can be expanded by another feature).\n\n6) UI structure and components\n- Create renderer/src/pages/TasksPage/ with components:\n  - TasksPage.tsx: page container and state management\n  - TaskFilters.tsx: search input + status checkboxes\n  - TaskList.tsx: renders list + empty/loading/error states\n  - TaskRow.tsx: individual row\n- Style with existing styling system (CSS Modules/Tailwind) or minimal CSS module for layout and badges.\n\n7) State and data flow in TasksPage\n- Local state: tasks (TaskSummary[]), loading, error, searchQuery (string), selectedStatuses (Set<TaskStatus>)\n- useEffect(() => { loadTasks() }, []) where loadTasks calls getTasks(), sets loading/error accordingly.\n- Derived filteredTasks computed via useMemo from tasks, searchQuery, selectedStatuses.\n  - Search: case-insensitive substring match on id and title.\n  - Filters: include task if selectedStatuses is empty OR selectedStatuses has task.status.\n\n8) Filters UI (TaskFilters)\n- Accessible search input:\n  - <label htmlFor=\"task-search\">Search tasks</label>\n  - <input id=\"task-search\" type=\"search\" value={searchQuery} onChange=... placeholder=\"Search by id or title\" />\n  - Clear button (type=button) that resets searchQuery when visible.\n- Status filter group:\n  - Wrap in <fieldset><legend>Status filters</legend> ...</fieldset>\n  - Checkboxes for each status: Todo, In progress, Blocked, Done\n  - Maintain selectedStatuses via onChange toggling.\n\n9) List and Empty/Loading/Error states (TaskList)\n- Loading: show skeleton rows (e.g., 5 gray bars with aria-hidden) and aria-live polite message \"Loading tasks\u2026\".\n- Error: show message \"Could not load tasks\" and a Retry button that calls loadTasks.\n- Empty states:\n  - If tasks length === 0 after load: \"No tasks available yet.\"\n  - If filteredTasks length === 0 but tasks > 0: \"No tasks match your search/filters\" with a Clear filters button to reset search and filters.\n- Render count summary with aria-live: \"Showing X of Y tasks\".\n\n10) TaskRow content and semantics\n- Each row rendered as a button-like element for keyboard activation while preserving list semantics:\n  - <li><button className=\"row\" onClick={openDetails} onKeyDown={handleKeyDown} aria-label={`Open task ${id}: ${title}`}> ... </button></li>\n- Display:\n  - Left: monospaced id\n  - Middle: title (truncate with ellipsis)\n  - Right: status badge with color + Features: done/total\n- Provide title attribute with full title for hover.\n\n11) Navigation behavior\n- openDetails navigates to /tasks/{id} using useNavigate from React Router.\n- handleKeyDown supports Enter/Space to open; Up/Down arrow optional (see step 12).\n\n12) Keyboard navigation\n- Default Tab navigation is sufficient; enhance with optional roving tabindex for arrow up/down among rows:\n  - Maintain focusedRowIndex state; on ArrowUp/ArrowDown, move focus to previous/next row button.\n  - Ensure no keyboard trap; Esc does nothing.\n\n13) Accessibility\n- Ensure labels for search and filters; fieldset/legend for checkbox group.\n- Buttons have accessible names; list has role=list and each row role=listitem (implicit via li).\n- Use aria-live=\"polite\" for result count updates.\n- Status badges must pass color contrast (use text + background choices accordingly).\n- Focus outline visible for interactive elements.\n\n14) Performance considerations\n- For now, simple list rendering; add react-window virtualization only if list size > ~500 in future tasks.\n- useMemo for filteredTasks to avoid unnecessary re-computation when typing.\n\n15) Testing\n- Unit tests (renderer) for filter function with cases: search only, status only, combined, empty, case-insensitive.\n- Component tests with React Testing Library:\n  - Renders from mocked API data and shows correct counts and rows.\n  - Search narrows results; clearing restores.\n  - Status filters work (single and multiple selections).\n  - Empty states render appropriately.\n  - Keyboard: Enter/Space triggers navigation; Tab focus order correct.\n  - Basic a11y using jest-axe (no violations for the page core flow).\n\n16) Type safety and linting\n- Strongly type IPC payloads and window.tasksAPI. Ensure no any leaks.\n- Add eslint rules for accessibility (jsx-a11y) if not already present.\n\n17) Visual polish\n- Status badge styles: todo (gray), in_progress (blue), blocked (red), done (green).\n- Monospace for IDs, truncate long titles, consistent spacing.\n\n18) Documentation\n- docs/ui/tasks-list.md: overview, data shape, IPC contract, component responsibilities, a11y notes, and testing strategy.\n\n19) Integration checklist (acceptance criteria mapping)\n- Renders list from IPC data: Verify getTasks IPC wired and list displays items.\n- Filtering/search applied client-side: Verify search and status filters adjust the derived list without re-fetch.\n- Empty states handled: No data, no matches, error, and loading states exist and are readable.\n- Accessibility basics covered: Labels, fieldset/legend, focus, keyboard activation, aria-live counts, contrast for badges.\n\n20) Optional: live updates hook (future)\n- Outline but do not implement now: an IPC event 'tasks:updated' + preload onUpdated(callback) to refresh list when tasks change.\n",
      "context": [],
      "acceptance": []
    },
    {
      "id": "5.8",
      "status": "-",
      "title": "Task details view with feature list and editing notes/fields",
      "description": "Create a detail page showing the task metadata and its features with statuses. Implement controlled editing for permitted fields (e.g., description, notes, status) with schema validation and disk write-back via task:update IPC. Provide change preview and basic error handling. Acceptance: Edits persist to task.json on disk, schema-valid; changes reflected in UI and index; guard rails prevent schema-breaking updates; unit/e2e tests simulate common edits.",
      "plan": "Implementation Plan: Task details view with feature list and editing notes/fields\n\n1) Data model and validation\n1.1 Define a canonical task schema in a shared module\n    - Create src/shared/schemas/task.ts using Zod (or Ajv if preferred) to describe the full task JSON shape.\n      Example (adjust to existing project fields if present):\n        const TaskStatus = z.enum([\"todo\",\"in-progress\",\"blocked\",\"done\"]);\n        const Feature = z.object({ id: z.string(), title: z.string(), status: TaskStatus, description: z.string().optional(), acceptance: z.string().optional() });\n        export const TaskSchema = z.object({\n          id: z.string(),\n          title: z.string(),\n          status: TaskStatus,\n          description: z.string().default(\"\"),\n          notes: z.string().default(\"\"),\n          priority: z.string().optional(),\n          features: z.array(Feature).default([]),\n          // ...add other known metadata with safe defaults\n        });\n        export type Task = z.infer<typeof TaskSchema>;\n    - Define AllowedEditableFields = [\"description\", \"notes\", \"status\"].\n    - Export a helper validateTask(data): { ok: boolean; value?: Task; error?: string }.\n\n1.2 Stable JSON formatting utility\n    - Add src/shared/json.ts with export function stableStringify(obj) using JSON.stringify(obj, null, 2) for consistent diffs.\n\n2) Main process: tasks service and IPC\n2.1 Tasks service for read/write\n    - Create src/main/services/tasks.ts with functions:\n      - getTaskPath(id: string): string \u2013 resolve to tasks/<id>/task.json (or pull from config).\n      - readTask(id: string): Promise<{ task: Task; version: { mtimeMs: number; hash: string } }>\n        \u2022 Read JSON, parse, validate with TaskSchema.\n        \u2022 Compute version: mtimeMs from fs.stat and hash via sha256(stringified file).\n      - updateTask(id: string, changes: Partial<Pick<Task, typeof AllowedEditableFields[number]>>, baseVersion: { mtimeMs: number; hash: string }): Promise<{ task: Task }>\n        \u2022 Read current file and version.\n        \u2022 Concurrency guard: if current.hash !== baseVersion.hash or mtime differs beyond tolerance, throw { code: 'VERSION_CONFLICT' }.\n        \u2022 Whitelist: Filter changes to AllowedEditableFields only; type-check each value.\n        \u2022 Merge: const next = { ...current, ...filteredChanges }.\n        \u2022 Validate next with TaskSchema; if invalid, throw { code: 'VALIDATION_ERROR', details }.\n        \u2022 Atomic write: write to tmp file (path + \".tmp\") with stableStringify, fs.rename to target; optionally create a .bak first if desired.\n        \u2022 Return updated task.\n\n2.2 IPC channels\n    - In src/main/ipc/tasks.ts register handlers in app ready:\n      - ipcMain.handle('task:get', async (_, { id }) => readTask(id))\n      - ipcMain.handle('task:update', async (_, { id, changes, baseVersion }) => {\n          try { const { task } = await updateTask(id, changes, baseVersion); \n                win.webContents.send('tasks:updated', { id, task });\n                return { ok: true, task }; \n          } catch (e) { return { ok: false, error: serializeIpcError(e) }; }\n        })\n    - Implement serializeIpcError to map codes: VERSION_CONFLICT, VALIDATION_ERROR, FS_ERROR.\n\n3) Renderer: routing and data access\n3.1 Route\n    - Add route /tasks/:id to the React Router. Create pages/TaskDetailsPage.tsx.\n\n3.2 IPC client helpers\n    - Add src/renderer/ipc/tasks.ts:\n      - getTask(id): invoke('task:get', { id }).\n      - updateTask(id, changes, baseVersion): invoke('task:update', { id, changes, baseVersion }).\n      - subscribeUpdated(cb): ipcRenderer.on('tasks:updated', cb) (cleanup on unmount).\n\n4) UI: Task details page\n4.1 Layout\n    - Header: task title, ID, and editable Status select (restricted to enum values).\n    - Metadata section: show non-editable fields (priority, etc.).\n    - Description: Markdown editor textarea with live preview toggle; sanitize with DOMPurify on preview.\n    - Notes: Simple textarea (or Markdown too if desired) with preview toggle.\n    - Features list: read-only table/list of features with their statuses; show badge colors by status.\n    - Actions: Save, Cancel, and a \"Preview changes\" button to open a modal showing diffs.\n\n4.2 State management\n    - Fetch on mount: const { task, version } = await getTask(id); keep originalTaskRef and baseVersionRef.\n    - Local form state: use React state or react-hook-form; initialize with task fields.\n    - Dirty tracking: compute isDirty by shallow comparing editable fields to original. Prompt on route change/close if dirty (beforeunload and router blocker).\n\n4.3 Change preview modal\n    - Build a list of field diffs only for AllowedEditableFields that changed.\n    - For text fields (description, notes): show side-by-side or inline unified diff (use diff-match-patch or fast-diff) plus a Markdown-rendered preview of new content.\n    - For status: show from -> to.\n\n4.4 Save flow\n    - Build changes object with only fields that differ and pass baseVersion from initial load.\n    - Call updateTask via IPC; on success:\n      \u2022 Update originalTaskRef and baseVersionRef using result of a fresh getTask(id) (or use returned task and recompute version with a subsequent get if needed).\n      \u2022 Update local state to match saved task.\n      \u2022 Emit toast \"Task saved\" and close preview modal if open.\n      \u2022 Let tasks list or other views update via 'tasks:updated' event in their stores.\n    - On error:\n      \u2022 VERSION_CONFLICT: show modal explaining file changed externally; options: Reload (discard edits), Overwrite anyway (disable for this feature, or allow via forcing update by skipping version check \u2014 keep it out-of-scope to stay safe), Copy my edits to clipboard.\n      \u2022 VALIDATION_ERROR: highlight offending fields and show message.\n      \u2022 FS_ERROR: show retry/cancel.\n\n4.5 Guard rails in UI\n    - Only render controls for AllowedEditableFields.\n    - Enforce enum for status.\n    - Limit description/notes length with soft max (e.g., 100k chars) to avoid huge writes.\n    - Sanitize markdown preview.\n\n5) Index/list synchronization\n    - Wherever the task index is shown, subscribe to 'tasks:updated' and update the in-memory store for that id.\n    - Verify that after saving, the index reflects new status/description snippet.\n\n6) Testing\n6.1 Unit tests (Jest)\n    - task schema: accepts valid tasks; rejects invalid statuses; defaults missing description/notes/features.\n    - tasks service updateTask:\n      \u2022 Applies only whitelisted fields; rejects extra keys.\n      \u2022 Fails on version conflict; succeeds after reread.\n      \u2022 Validates and writes atomically (use memfs or tmp dirs; verify final file contents).\n    - IPC handlers: return shapes { ok: true/false } and map errors correctly.\n\n6.2 Component tests (React Testing Library)\n    - TaskDetailsPage renders metadata, features list, and editable fields.\n    - Editing description toggles dirty state and enables Save.\n    - Preview modal shows correct diffs for text and status.\n    - On save success, dirty state clears and toast appears.\n    - Validation error displays correctly (mock IPC).\n\n6.3 E2E tests (Playwright or Spectron)\n    - Launch app with a fixture project containing a sample task.json.\n    - Navigate to Task details; modify description and status; open preview; save; verify disk file content changed and index view shows updated status.\n    - Simulate external change (modify file between load and save) and verify conflict handling dialog.\n\n7) Implementation details and utilities\n7.1 Hashing and versioning\n    - Use node:crypto createHash('sha256').update(fileContents).digest('hex').\n    - Store and pass both mtimeMs and hash, but rely on hash for conflict decision.\n\n7.2 Atomic write helper\n    - writeAtomic(path, contents): write to path + '.tmp', fs.fsync, rename to path. Optionally keep a .bak on first write in dev.\n\n7.3 Markdown rendering\n    - Use markdown-it or marked in renderer; sanitize with DOMPurify; allow code highlighting if available.\n\n7.4 Error mapping\n    - Standardize IPC error payload: { code, message, details? } and avoid exposing stack traces in renderer.\n\n8) Documentation\n    - Add docs/dev/task-details.md covering:\n      \u2022 Task schema and editable fields\n      \u2022 IPC contract for task:get and task:update\n      \u2022 Concurrency behavior\n      \u2022 How to add a new editable field safely\n      \u2022 Testing instructions\n\n9) Acceptance checklist mapping\n    - Edits persist to task.json on disk: Verified via unit (memfs) and e2e (real file) tests.\n    - Schema-valid: Main process validates with TaskSchema; tests cover invalid updates.\n    - Changes reflected in UI and index: 'tasks:updated' event updates stores; e2e asserts list shows new status.\n    - Guard rails prevent schema-breaking updates: Whitelist in main, enum constraints in UI and validator; unit tests cover.\n    - Unit/e2e tests simulate common edits: Description/notes/status success; invalid status fail; version conflict path.",
      "context": [],
      "acceptance": []
    },
    {
      "id": "5.9",
      "status": "-",
      "title": "Markdown documentation explorer and renderer",
      "description": "Implement a docs browser that lists Markdown files under docs/ (including docs/tasks/*). Render Markdown with basic extensions (tables, code highlighting), safe HTML sanitization, and internal link navigation. Acceptance: Sidebar shows directory tree; renderer supports anchors and code blocks; clicking internal links navigates within the app; large files render efficiently; tested with provided docs/*.md.",
      "plan": "",
      "context": [],
      "acceptance": []
    },
    {
      "id": "5.10",
      "status": "-",
      "title": "Read-only Git status panel",
      "description": "Expose project Git status via IPC by invoking the git CLI or a lightweight library. Show current branch, ahead/behind, changed files, and submodule summary. No write operations from this panel. Acceptance: Works across platforms; handles repositories with submodules; performance acceptable; unit tests stub git outputs; UI displays clear status indicators.",
      "plan": "",
      "context": [],
      "acceptance": []
    },
    {
      "id": "5.11",
      "status": "-",
      "title": "Agent process manager (start/stop/list, logs)",
      "description": "Implement process orchestration to run local agents via scripts/run_local_agent.py (or equivalent). Configurable Python interpreter path. Provide UI to start/stop agents, view running processes, and stream stdout/stderr logs with persistence. Acceptance: Start/stop works with sample agent; logs stream and are saved to file; broken interpreter path yields clear error; protected from multiple accidental starts; IPC: agents:list/start/stop/logs implemented.",
      "plan": "",
      "context": [],
      "acceptance": []
    },
    {
      "id": "5.12",
      "status": "-",
      "title": "Agent activity detection and completion notifications",
      "description": "Detect agent progress by monitoring process lifecycle and file changes in tasks/ (e.g., updated task.json or tests). When an agent finishes or triggers notable changes, show OS notifications and add to an in-app notifications center. Acceptance: File watcher identifies relevant changes; notification includes agent name and summary; user can mute/disable; tested with simulated runs; no duplicate spam.",
      "plan": "",
      "context": [],
      "acceptance": []
    },
    {
      "id": "5.13",
      "status": "-",
      "title": "Notifications center UI and preferences",
      "description": "Add a notifications panel listing recent events (agent started/stopped, edits saved, git changes). Provide settings to enable/disable OS notifications and categories. Acceptance: Notifications persist across reloads; can be marked as read; preferences stored in settings; OS notifications use Electron Notification with fallbacks.",
      "plan": "",
      "context": [],
      "acceptance": []
    },
    {
      "id": "5.14",
      "status": "-",
      "title": "Chat interface UI (sessions, messages, basic send/receive)",
      "description": "Create a chat UI with session list, message view, composer with multiline input, and send action. Persist conversation locally. Pluggable model selector. Acceptance: New session, rename session, message history persists; keyboard shortcuts (Shift+Enter for newline, Enter to send configurable); empty/error states handled; uses llm:chat IPC stub.",
      "plan": "",
      "context": [],
      "acceptance": []
    },
    {
      "id": "5.15",
      "status": "-",
      "title": "LLM connector abstraction and providers (LiteLLM, OpenAI-compatible)",
      "description": "Design an abstraction for chat providers. Implement connectors for: (1) LiteLLM-compatible HTTP endpoint, (2) OpenAI-compatible custom base URL to support LM Studio / Ollama. Configurable API key, base URL, model name, timeouts. Acceptance: Provider interface documented; connectors unit-tested with mocked servers; UI to add/edit providers; failing requests produce actionable errors.",
      "plan": "",
      "context": [],
      "acceptance": []
    },
    {
      "id": "5.16",
      "status": "-",
      "title": "Read-only tool adapters for chat",
      "description": "Implement tools accessible from chat with strict read-only capabilities: read_file, list_dir (scoped to project root), docs_index, read_doc, tasks_index, get_task, git_status, list_agents, agent_log_tail. Enforce allowlists and path sandboxing. Acceptance: Tools cannot write to disk; attempts to escape sandbox blocked; usage audited/logged; tool registry exposes metadata; covered by security unit tests.",
      "plan": "",
      "context": [],
      "acceptance": []
    },
    {
      "id": "5.17",
      "status": "-",
      "title": "Chat tool permissions and admin gating",
      "description": "Add UI and backend enforcement for enabling/disabling tools per session. Provide a clear indicator in the chat UI of which tools are enabled. Acceptance: Disabled tools are not invocable; permissions persist; attempting to call a disabled tool returns a controlled error; tests verify enforcement at IPC and provider levels.",
      "plan": "",
      "context": [],
      "acceptance": []
    },
    {
      "id": "5.18",
      "status": "-",
      "title": "Context retrieval for chat (RAG-lite)",
      "description": "Implement simple keyword-based search over project docs and tasks. Allow user to attach retrieved snippets into context before sending. Optionally auto-attach top-k snippets with a toggle. Acceptance: Search returns ranked results quickly; selected snippets previewed; tokens limited by model configuration; unit tests confirm deterministic retrieval on fixed corpora.",
      "plan": "",
      "context": [],
      "acceptance": []
    },
    {
      "id": "5.19",
      "status": "-",
      "title": "Child projects overview (submodules browser)",
      "description": "List submodules under projects/ with name, URL, current commit, and dirty status. Provide quick links to open in file explorer or terminal. Acceptance: Handles absent submodules gracefully; data sourced via git plumbing; UI updates when submodule pointers change; read-only operations only.",
      "plan": "",
      "context": [],
      "acceptance": []
    },
    {
      "id": "5.20",
      "status": "-",
      "title": "Cross-platform packaging configuration",
      "description": "Configure electron-builder to produce distributables for macOS (dmg), Windows (nsis), and Linux (AppImage). Include app icons and code signing placeholders. Acceptance: CI-local builds produce artifacts; metadata correct (name, version, copyright); app auto-updates disabled initially.",
      "plan": "",
      "context": [],
      "acceptance": []
    },
    {
      "id": "5.21",
      "status": "-",
      "title": "CI pipeline for build and release",
      "description": "Add GitHub Actions workflows to lint, type-check, build, and produce release artifacts on tags. Cache dependencies for speed. Optionally draft release with artifacts attached. Acceptance: CI green on main; tag push triggers build for all OS targets; artifacts downloadable; secrets managed securely (no plaintext keys).",
      "plan": "",
      "context": [],
      "acceptance": []
    },
    {
      "id": "5.22",
      "status": "-",
      "title": "Developer documentation and runbook",
      "description": "Complete docs: ARCHITECTURE.md (process boundaries, IPC contract), DEVELOPMENT.md (setup, scripts), SECURITY.md (IPC, sandbox, tool restrictions), PROVIDERS.md (LLM connectors), AGENTS.md (how agent processes are managed), and a quickstart. Acceptance: Docs pass link check; examples tested; contributors can set up locally following docs without assistance.",
      "plan": "",
      "context": [],
      "acceptance": []
    }
  ]
}