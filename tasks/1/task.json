{
  "id": 1,
  "status": "-",
  "title": "Task Management System Definition",
  "description": "Define and maintain the core components of the agent's task management system. This task serves as the canonical source of truth for task structure, guidance, and tooling.",
  "features": [
    {
      "id": "1.1",
      "status": "-",
      "title": "Canonical Task Schema",
      "description": "Define and maintain the canonical schema for tasks in `docs/tasks/task_format.py` using Python's TypedDict.",
      "plan": "1. The `docs/tasks/task_format.py` file serves as the single source of truth for the data structures of `Task` and `Feature` objects. 2. Any changes to the task format must be reflected here first.",
      "context": [
        "docs/tasks/task_format.py"
      ],
      "acceptance": [
        "The file 'docs/tasks/task_format.py' exists.",
        "The file defines a TypedDict named 'Task'.",
        "The file defines a TypedDict named 'Feature'.",
        "The 'Task' TypedDict has exactly the following fields: 'id' of type str, 'title' of type str, 'features' of type list[Feature].",
        "The 'Feature' TypedDict has exactly the following fields: 'id' of type str, 'title' of type str, 'description' of type str, 'acceptance_criteria' of type list[str]."
      ]
    },
    {
      "id": "1.2",
      "status": "-",
      "title": "Example Task File",
      "description": "Maintain a complete and valid example task file at `docs/tasks/task_example.json`.",
      "plan": "1. This file serves as a practical, copy-pasteable template for new tasks. 2. It must always be kept in sync with the canonical schema defined in `task_format.py`.",
      "context": [
        "docs/tasks/task_format.py",
        "docs/tasks/task_example.json"
      ],
      "acceptance": [
        "`docs/tasks/task_example.json` exists.",
        "The file contains a valid JSON object.",
        "The JSON object structure conforms to the `Task` schema."
      ],
      "dependencies": [
        "1.1"
      ]
    },
    {
      "id": "1.3",
      "status": "+",
      "title": "File Organisation specification",
      "description": "Create a scheme for organising files within the repository.",
      "plan": "1. Create the file `docs/FILE_ORGANISATION.md`. 2. Add the required sections: `Top-Level Directory Layout`, `File Naming Conventions`, and `Evolution Guidance`. 3. Populate each section with clear, concise guidelines and examples relevant to this project structure.",
      "context": [
        "docs/FILE_ORGANISATION.md"
      ],
      "acceptance": [
        "`docs/FILE_ORGANISATION.md` exists",
        "It includes clearly titled sections: `Top-Level Directory Layout`, `File Naming Conventions`, `Evolution Guidance` and Example tree (illustrative) - showing in a `graphical` way the file structure",
        "Each section provides concise explanations and examples where helpful"
      ]
    },
    {
      "id": "1.4",
      "status": "-",
      "title": "Testing",
      "description": "Establish the canonical, project-wide testing specification and integrate testing requirements into the planning specification so every feature is verifiable by deterministic tests.",
      "plan": "1. Create the file `docs/TESTING.md`. 2. Define the project's testing philosophy, scope, and structure. 3. Specify file locations (`tasks/{id}/tests/`) and naming conventions (`test_{task_id}_{feature_id}.py`). 4. Document testing tools (`run_tests`) and the development workflow.",
      "context": [
        "docs/TESTING.md"
      ],
      "acceptance": [
        "The file 'docs/TESTING.md' exists.",
        "The file 'docs/TESTING.md' contains the Markdown heading '## Philosophy'.",
        "The file 'docs/TESTING.md' contains the Markdown heading '## Scope'.",
        "The file 'docs/TESTING.md' contains the Markdown heading '## Structure'.",
        "The file 'docs/TESTING.md' contains the Markdown heading '## Location'.",
        "The file 'docs/TESTING.md' contains the Markdown heading '## Naming Conventions'.",
        "The file 'docs/TESTING.md' contains the Markdown heading '## Tooling'.",
        "The file 'docs/TESTING.md' contains the Markdown heading '## Workflow'."
      ]
    },
    {
      "id": "1.5",
      "status": "-",
      "title": "Agent communication porotocol",
      "description": "Create a file that specifies the json format that an agent needs to return so that it's possible to  have a multi-step conversation and an agent can call tools",
      "context": [
        "docs/AGENT_COMMUNICATION_PROTOCOL.md"
      ],
      "acceptance": [
        "A document `docs/AGENT_COMMUNICATION_PROTOCOL.md` exists explaining the protocol",
        "`docs/agent_response_example.json` exists containg a valid JSON object defining the format  for agent responses as an example json."
      ],
      "plan": "Implementation Plan for Feature 1.5: Agent Communication Protocol\n\nObjective: Define a standardized JSON format for agent outputs to enable multi-step conversations and tool calls. This format allows agents to reason, call tools, and continue or finish interactions.\n\nStep 1: Choose file name and location.\n- Create a new Markdown file named 'agent_communication_protocol.md' in the 'docs/' directory of the project. If 'docs/' doesn't exist, create it.\n\nStep 2: Introduce the purpose.\n- In the file, start with a section explaining the purpose: to standardize agent outputs for parseability, supporting tool invocations and conversational flow.\n\nStep 3: Define the JSON structure.\n- Specify that every agent response MUST be a single, valid JSON object with exactly two fields:\n  - \"thoughts\": A string (required) containing the agent's reasoning, analysis, and any relevant explanations.\n  - \"tool_calls\": An array (required, can be empty) of objects, each representing a tool to call.\n    - Each tool call object has:\n      - \"tool_name\": String (required), the exact name of the tool.\n      - \"arguments\": Object (required), a dictionary of argument names and values as per the tool's signature.\n- Note: The response must not contain any text outside this JSON object.\n\nStep 4: Explain multi-step conversations and tool calls.\n- Describe how this enables multi-step: Agents output thoughts and tool_calls. The system processes tool_calls, provides results back to the agent in the next input, allowing continuation.\n- If \"tool_calls\" is empty, it indicates the agent has finished its task, and \"thoughts\" may contain the final output or summary.\n- For finishing tasks, agents may call special tools like 'finish_feature' if applicable.\n\nStep 5: Provide examples.\n- Include JSON examples:\n  - Tool call example: {\"thoughts\": \"I need to get context from files.\", \"tool_calls\": [{\"tool_name\": \"get_context\", \"arguments\": {\"files\": [\"file1.txt\"]}}]}\n  - No tool call (finish): {\"thoughts\": \"Task complete, no further actions needed.\", \"tool_calls\": []}\n  - Multiple tool calls: {\"thoughts\": \"Calling two tools in parallel.\", \"tool_calls\": [{\"tool_name\": \"tool1\", \"arguments\": {}}, {\"tool_name\": \"tool2\", \"arguments\": {}}]}\n\nStep 6: Add validation and best practices.\n- Emphasize that the JSON must be valid and parseable.\n- Handle errors: If format is invalid, the system may reject or retry.\n- Best practices: Keep thoughts concise but informative; ensure tool names and arguments match available tools.\n\nStep 7: Review and finalize.\n- Ensure the file is clear, well-formatted with headings, and comprehensive."
    },
    {
      "id": "1.6",
      "status": "-",
      "title": "Plan specification for Planner",
      "description": "Create a specification for the Planner task that describes how to create a task with features that clearly describe the full scope of the task, and how to create a plan for each feature. This document is meant to be directly passed to a planner agent and alongside `docs/AGENT_PLANNER.md` serve as their starting point and guide.",
      "context": [
        "docs/tasks/task_format.py",
        "docs/tasks/task_example.json",
        "docs/AGENT_COMMUNICATION_PROTOCOL.md",
        "docs/agent_response_example.json",
        "docs/AGENT_PLANNER.md"
      ],
      "acceptance": [
        "`docs/AGENT_PLANNER.md` exists",
        "The document describes an agent that looks at the task description and creates a plan for completing a task following the given specifications.",
        "The document references `docs/tasks/task_format.py` for the task schema",
        "The document references `docs/tasks/task_example.json` for the task example",
        "The document references `docs/AGENT_COMMUNICATION_PROTOCOL.md` and `docs/agent_response_example.json` to explain how the communication protocol works and how to respond",
        "The document has a section `Tools` that list and describe all tools this agent can use: `create_task(task:Task)->Task`, `create_feature(feature:Feature)->Feature`, `update_task(id:int,title:str,action:str,plan:str)->Task`, `update_feature(task_id:int,feature_id:str,title:str,action:str,context:[str],plan:str)->Feature`, `block_feature(task_id:int,feature_id:str,reason:str)`",
        "The document explains that creating a task with features that clearly describe the full scope of the task is mandatory - `create_task` tool is used for this",
        "The document explains that creating features that are missing for the task to be complete is mandatory - `create_feature` tool is used for this",
        "The document explains that the task requires a generic high level plan - `update_task` tool is used for this",
        "The document explains that each feature requires a step-by-step plan that should make it easy to implement for an LLM - `update_feature` tool is used for this",
        "The document explains that each feature requires gathering a minimal context that is required per feature - `update_feature` tool is used for this",
        "The document explains that if there's any unresolved issue - the `block_feature` tool is used for this"
      ],
      "dependencies": [
        "1.1",
        "1.2",
        "1.3"
      ],
      "plan": "# Planner Task Specification\n\n## Overview\nThis specification serves as a guide for the Planner agent in creating and managing tasks within the system. It details how to define a task, break it down into features that fully cover its scope, and create detailed implementation plans for each feature. This document, combined with any agent persona guidelines, provides the starting point for planning operations. The Planner agent's goal is to ensure tasks are decomposed logically, plans are thorough, and tools are used effectively to advance the project.\n\n## Key Principles\n- **Completeness**: Features must collectively cover the entire scope of the task without gaps or overlaps.\n- **Clarity**: Descriptions should be precise, actionable, and self-contained.\n- **Step-by-Step Planning**: Plans for features should be detailed, sequential, and tool-oriented.\n- **Tool Usage**: Leverage available tools like `get_context`, `update_feature_plan`, `finish_feature`, `block_feature`, and `create_feature` appropriately.\n\n## Step 1: Understanding the Assigned Task\n- Receive the CURRENT TASK, which includes an ID, name, and description.\n- Analyze the task to understand its full scope, objectives, and requirements.\n- If needed, use `get_context` to retrieve relevant files or documentation for background information.\n\n## Step 2: Breaking Down the Task into Features\n- Decompose the task into smaller, manageable features.\n- Each feature should:\n  - Have a unique ID (e.g., taskID.subID like 1.1).\n  - Have a clear name.\n  - Have a detailed description that defines its scope, inputs, outputs, and dependencies.\n- Ensure features are:\n  - **Atomic**: Focused on one primary aspect.\n  - **Comprehensive**: Together, they address every part of the task.\n  - **Non-overlapping**: Avoid redundancy.\n- Use the `create_feature` tool to add each feature. The feature dict should include keys like 'id', 'name', 'description', and any other relevant fields.\n- Example, if necessary, re-plan if the features require sub-features.\n\n## Step 3: Creating a Plan for Each Feature\n- For each feature, develop a detailed, step-by-step implementation plan.\n- The plan should include:\n  1. **Analysis**: Reason about the feature's requirements, potential challenges, and approach.\n  2. **Research/Context Gathering**: Use `get_context` to fetch necessary files or info.\n  3. **Step-by-Step Steps**: Outline sequential actions, including tool calls where applicable.\n  4. **Tool Integration**: Specify when to use tools (e.g., `update_feature_plan` to save progress, `block_feature` if issues arise).\n  5. **Completion**: End with calling `finish_feature` when the plan is ready.\n- Save the plan using `update_feature_plan` with the plan string.\n\n## Step 4: Handling Issues\n- If a feature cannot proceed (e.g., dependencies unmet), use `block_feature` with a reason.\n- Reassess and adjust features/plans as needed.\n\n## Step 5: Task Completion\n- Once all features have plans and are finished, the task is complete.\n- Ensure all outputs align with the overall task goals.\n\n## Response Format\n- Always respond in a valid JSON object with 'thoughts' (reasoning) and 'tool_calls' (list of actions).\n- Keep responses concise yet thorough.\n\nThis specification ensures structured, efficient planning. Adhere to it strictly for consistency."
    },
    {
      "id": "1.7",
      "status": "-",
      "title": "Plan specification for Tester",
      "description": "Create a specification for the tester task that describes how to create acceptance criteria for each feature, and in turn the tests that verify the acceptance criteria. This document is meant to be directly passed to a tester agent and alongside `docs/AGENT_TESTER.md` serve as their starting point and guide.",
      "context": [
        "docs/TESTING.md",
        "docs/AGENT_COMMUNICATION_PROTOCOL.md",
        "docs/agent_response_example.json",
        "docs/AGENT_TESTER.md"
      ],
      "acceptance": [
        "`docs/AGENT_TESTER.md` exists",
        "The document references `docs/TESTING.md` for testing guidance",
        "The document references `docs/AGENT_COMMUNICATION_PROTOCOL.md` and `docs/agent_response_example.json` to explain how the communication protocol works and how to respond",
        "The document has a section `Tools` that list and describe all tools this agent can use: `get_test(task_id:int,feature_id:str)->str?`, `update_acceptance_criteria(task_id:int,feature_id:str,criteria:[str])->Feature`, `update_test(task_id:int,feature_id:str,test:str)`, `delete_test(task_id:int,feature_id:str)`, `run_test(task_id:int,feature_id:str)->TestResult`, `update_task_status(task_id:int,status:Status)->Task`, `update_feature_status(task_id:int,feature_id:str,status:Status)->Feature`, `block_feature(task_id:int,feature_id:str,question:str)`",
        "The document explains that for each feature the required context needs to be gathered, for this persona it means the test for that feature - `get_test` tool is used for this, but this should be directly passed in the initial context",
        "The document explains that each feature requires rigorous and atomic acceptance criteria - `update_acceptance_criteria` tool is used for this",
        "The document explains that each feature requires tests written that match each acceptance criteria - `update_test`, `delete_test` tools are used for this",
        "The document explains that the tester can run tests - `run_test` tool is used for this",
        "The document explains that the task status needs to be updated when work is not finished - `update_task_status` tool is used for this",
        "The document explains that each feature status needs to be updated when work is not finished - `update_feature_status` tool is used for this",
        "The document explains that if there's any unresolved issue - the `block_feature` tool is used for this"
      ],
      "dependencies": [
        "1.1",
        "1.2",
        "1.3",
        "1.4"
      ],
      "plan": "# Tester Agent Specification\n\n## Overview\nThis specification serves as a guide for the Tester Agent in the Task Management System. Your role is to ensure that each feature meets its requirements through well-defined acceptance criteria and corresponding tests. This document, along with your persona in `docs/AGENT_PERSONAS_TESTER.md`, provides the foundation for your operations. You will receive features from the planner or developer agents and generate acceptance criteria and tests for them.\n\n## Step-by-Step Process\n\n### Step 1: Analyze the Assigned Feature\n- Review the feature description, ID, and any associated context (e.g., user stories, requirements, or related documents).\n- Identify the key functionalities, inputs, outputs, and edge cases.\n- Understand the feature's goals and how it fits into the overall system.\n- If needed, use available tools to gather more context (e.g., get_context for related files).\n\n### Step 2: Create Acceptance Criteria\n- Acceptance criteria are clear, testable statements that define when a feature is complete and working as expected.\n- For each feature, generate 3-7 acceptance criteria, covering:\n  - Happy paths (normal usage).\n  - Edge cases (e.g., invalid inputs, boundary conditions).\n  - Error handling (e.g., failures, exceptions).\n  - Non-functional aspects (e.g., performance, security, if applicable).\n- Format each criterion using the Given-When-Then structure:\n  - **Given** [preconditions],\n  - **When** [action is performed],\n  - **Then** [expected outcome].\n- Ensure criteria are measurable, unambiguous, and verifiable.\n- Document them in a list or table for clarity.\n\n### Step 3: Develop Tests for Acceptance Criteria\n- For each acceptance criterion, create one or more tests that verify it.\n- Tests should be automated where possible, using a testing framework like pytest (for Python-based systems).\n- Types of tests to consider:\n  - Unit tests: For individual components.\n  - Integration tests: For interactions between components.\n  - End-to-end tests: For full feature flows.\n  - Manual tests: If automation is not feasible.\n- Structure each test:\n  - Test name: Descriptive and linked to the criterion.\n  - Setup: Prepare the environment or mocks.\n  - Execution: Perform the action.\n  - Assertion: Verify the outcome.\n- Include test data, expected results, and any dependencies.\n\n### Step 4: Review and Refine\n- Cross-check that all acceptance criteria cover the feature comprehensively.\n- Ensure tests are independent, repeatable, and maintainable.\n- If gaps are found, iterate on criteria and tests.\n- Use tools like block_feature if the feature cannot be tested due to issues (e.g., incomplete specs).\n\n### Step 5: Document and Report\n- Compile the acceptance criteria and tests into a single document or file (e.g., Markdown or test script).\n- If tests pass, mark the feature as verified using available tools (e.g., finish_feature).\n- Report any failures or issues back to the developer or planner agents.\n\n## Best Practices\n- Be thorough: Cover positive, negative, and boundary scenarios.\n- Stay objective: Base criteria on requirements, not assumptions.\n- Collaborate: If clarification is needed, query other agents or use tools.\n- Keep it concise: Avoid overly complex tests; aim for simplicity.\n\n## Example\n**Feature:** User Login (ID: 2.1)\n\n**Acceptance Criteria:**\n1. Given a user with valid credentials, When they submit the login form, Then they are redirected to the dashboard.\n2. Given invalid credentials, When login is attempted, Then an error message is displayed and access is denied.\n\n**Tests:**\n- Test 1: valid_login_test() - Setup user, simulate login, assert redirect.\n- Test 2: invalid_login_test() - Setup invalid creds, simulate login, assert error message.\n\nFollow this process for every assigned feature to ensure quality and reliability in the system."
    },
    {
      "id": "1.8",
      "status": "-",
      "title": "Plan specification for Developer",
      "description": "Create a specification for the developer task that describes how to implement each feature. This document is meant to be directly passed to a tester agent and alongside `docs/AGENT_DEVELOPER.md` serve as their starting point and guide.",
      "context": [
        "docs/FILE_ORGANISATION.md",
        "docs/AGENT_COMMUNICATION_PROTOCOL.md",
        "docs/agent_response_example.json",
        "docs/AGENT_DEVELOPER.md"
      ],
      "acceptance": [
        "`docs/AGENT_DEVELOPER.md` exists",
        "The document references `docs/AGENT_DEVELOPER.md` for agent developer guidance",
        "The document references `docs/FILE_ORGANISATION.md` for file structure guidance",
        "The document references `docs/AGENT_COMMUNICATION_PROTOCOL.md` and `docs/agent_response_example.json` to explain how the communication protocol works and how to respond",
        "The document has a section `Tools` that list and describe all tools this agent can use: `get_context(files:[str])->[str]`, `write_file(filename:str,content:str)`,`run_test(task_id:int,feature_id:str)->TestResult`, `update_task_status(task_id:int,status:Status)->Task`, `update_feature_status(task_id:int,feature_id:str,status:Status)->Feature`, `finish_feature(task_id:int,feature_id:str)->Feature`, `finish(task_id:int)->Task`,`block_feature(task_id:int,feature_id:str,question:str)`",
        "The document explains that the task status is updated to in progress - `update_task_status` tool is used for this",
        "The document explains that for each feature that is worked on the status is updated to in progress - `update_feature_status` tool is used for this",
        "The document explains that for each feature the context needs to be gathered - `get_context` tool is used for this, but this should be directly passed in the initial context and should only be used in very rare cases",
        "The document explains that for each feature the plan needs to be carried out - `write_file` tool is used for writing any files",
        "The document explains that for each feature the task isn't deemed done until all tests pass - `run_test` tool is used for this",
        "The document explains that for each feature the status needs to be updated when work is finished - `update_feature_status` tool is used for this",
        "The document explains that the task status needs to be updated when work is finished - `update_task_status` tool is used for this",
        "The document explains that if the work for the agent is done on a feature the `finish_feature` MUST BE USED",
        "The document explains that if the work for the agent is done on a task the `finish` MUST BE USED",
        "The document explains that if there's any unresolved issue - the `block_feature` tool is used for this"
      ],
      "dependencies": [
        "1.1",
        "1.2",
        "1.3",
        "1.4"
      ],
      "plan": "# Implementation Plan for Feature 1.8: Plan Specification for Developer\n\n**Objective**: Create a specification document that describes how developers should implement each feature in the system. This document will be passed to the tester agent along with `docs/AGENT_DEVELOPER.md` to serve as their starting point and guide for defining acceptance criteria and tests.\n\n**Step-by-Step Implementation Guide for the Developer**:\n\n1. **Analyze the Requirement**: Review the feature description. Understand that the specification must provide a general, reusable guide for implementing any feature, expanding on the workflow in `docs/AGENT_DEVELOPER.md`. It should be detailed enough for testers to base their criteria on it.\n\n2. **Determine File Location**: The document should be created as a new Markdown file named `docs/DEVELOPER_IMPLEMENTATION_SPEC.md`.\n\n3. **Craft the Content**: Use the `write_file` tool to create the file with the following structure and content:\n\n   ```markdown\n   # Specification for Developer Task: Implementing Features\n\n   This document provides a standardized specification for how developers should implement each assigned feature in the Task Management System. It serves as a guide for developers and is provided to tester agents alongside `docs/AGENT_DEVELOPER.md` to inform acceptance criteria and test creation.\n\n   ## Overview\n   For each feature, the developer receives a detailed implementation plan from the planner. The developer must follow the plan while adhering to the general workflow: implement changes, test, and complete or block.\n\n   ## Step-by-Step Process for Implementing a Feature\n   1. **Review Assignment**: Read the feature description, ID, and the provided implementation plan. Analyze requirements and use `get_context` to retrieve any necessary existing files or documentation if critical information is missing.\n   \n   2. **Plan Execution**: Break down the provided plan into actionable tasks. Identify files to create or modify.\n   \n   3. **Implement Changes**: Use the `write_file` tool to write or update code/files as specified in the plan. Ensure all changes align with the system's architecture.\n   \n   4. **Handle Dependencies**: If the feature requires new tools, agents, or integrations, implement them carefully, testing incrementally.\n   \n   5. **Testing**: Create or update the test script for the feature. Use `run_test` to execute it. Debug and iterate until all tests pass. Tests should verify that the implementation meets the plan's requirements.\n   \n   6. **Completion**: Once tests pass, call `finish_feature` to commit the work and mark the feature as done.\n   \n   7. **Blocking**: If stuck (e.g., unclear requirements, tool issues), call `block_feature` with a clear reason.\n\n   ## Best Practices\n   - Keep changes minimal and focused on the feature.\n   - Document code where necessary.\n   - Ensure compatibility with existing system components.\n\n   This specification ensures consistent implementations and enables testers to define verifiable criteria based on these steps.\n   ```\n\n4. **Validate**: After writing the file, use `get_context` to read it back and confirm the content is correct. If a test exists for this feature (e.g., checking file existence and content), use `run_test` to verify.\n\n5. **Complete the Feature**: If everything is correct and tests pass (or if no test is needed for this documentation task), call `finish_feature`. If blocked, use `block_feature` with the reason."
    }
  ]
}