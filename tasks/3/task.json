{
  "id": 3,
  "status": "-",
  "title": "New child projects structure",
  "description": "Create a new structure for child projects that stems from this project. This will be done by creating a new repository for each child project. Each child project is linked backed to this projct via git-submodules so that all the child projects are automatically updated whenever this project updates. This project drives the child projects and then the child projects can also be cloned independently if needed and will drive their own implementation work. The first project is `Docker`. We want to be able to run any project (including this + any child project) in a docker environment. It needs to be extremely easy to launch this - ideally a single function call to get it launched and then whatever function call needs to be called inside the running container. As a first example we should be able to launch this project in docker and call `run.py` to launch an agent exactly as defined in `LOCAL_SETUP.md`. There needs to be a step-by-step guide for this that exactly explains it.",
  "features": [
    {
      "id": "3.1",
      "status": "+",
      "title": "Document submodule workflow for child projects",
      "description": "Create clear documentation detailing how the projects/ folder is used with git submodules, including cloning, initialization, adding, updating, and removing child projects, plus common pitfalls.",
      "plan": "Feature: Document submodule workflow for child projects\n\nGoal\n- Provide a clear, authoritative guide for managing child projects as Git submodules in the parent repository, covering onboarding, daily operations, maintenance, CI/CD, auth, governance, versioning, and troubleshooting.\n\nAssumptions\n- Child projects live as Git submodules under the designated directory `projects/`. Adjust names to actual repo conventions during authoring.\n- Git v2.31+ and SSH access (recommended) or HTTPS with PAT are available to developers and CI.\n\nScope\n- Documentation only (primary). Optionally include small helper scripts and hooks to standardize developer operations.\n\nPlan and Steps\n\nPhase 1: Align on conventions and prerequisites\n1) Confirm directory structure and naming: decide the canonical path for submodules (e.g., children/<child-name>/) and naming conventions.\n2) Define submodule configuration policy:\n   - Tracking branch default (e.g., main) via .gitmodules submodule.<path>.branch.\n   - Shallow checkouts (shallow = true) where appropriate.\n   - Prefer SSH URLs (recommended) and provide HTTPS alternative.\n   - Decide on nested submodules policy (allow/avoid).\n3) Define versioning policy:\n   - Pin to tags for releases; pin to branch heads for ongoing development.\n   - Tagging strategy and compatibility expectations.\n4) Define governance and ownership:\n   - How CODEOWNERS applies to submodule paths.\n   - Approval requirements when bumping submodule pointers.\n5) Document required tools and access:\n   - Git version; SSH keys or PAT; org permissions.\n\nDeliverable: A concise \u201cSubmodule policy\u201d section to include at the top of the document.\n\nPhase 2: Author primary documentation (docs/child-projects/submodules.md)\nStructure and content:\n1) Overview and scope\n   - Why submodules are used; pros/cons; when to use.\n   - Repo structure diagram (textual tree) showing parent and children.\n2) Quickstart (fresh clone)\n   - Commands: git clone, git submodule update --init --recursive, optional config: git config submodule.recurse true.\n   - Verifying status: git submodule status.\n3) Daily workflows\n   a) Add a new child project\n      - Command sequence:\n        - git submodule add -b <branch> <ssh-url> children/<name>\n        - git config -f .gitmodules submodule.children/<name>.branch <branch>\n        - Optional shallow: git config -f .gitmodules submodule.children/<name>.shallow true\n        - git add .gitmodules children/<name>\n        - git commit -m \"Add submodule: <name> at <branch>\"\n      - Notes: URL conventions; .gitmodules review; CODEOWNERS update.\n   b) Update a child to latest\n      - Quick path: git submodule update --remote --merge children/<name>\n      - Manual path: cd children/<name>; git fetch; git checkout <branch-or-tag>; cd -; git add children/<name>; git commit -m \"Bump <name> to <ref>\"\n      - Locking to a tag vs tracking a branch.\n   c) Work on a child repo (feature development)\n      - cd children/<name>; git switch -c feat/x; implement; push; open PR in child repo; merge there; then bump pointer in parent with a commit message referencing the child PR.\n   d) Coordinated multi-repo change\n      - Create matching branches in each child and the parent; open cross-referenced PRs; order of merges; then fast-forward parent pointers; include rollback strategy.\n   e) Verify and commit submodule pointer changes\n      - git status shows modified content at path; ensure no local dirty state in submodules; commit pointer updates.\n4) Maintenance workflows\n   a) Remove a submodule\n      - Commands:\n        - git submodule deinit -f children/<name>\n        - rm -rf .git/modules/children/<name>\n        - git rm -f children/<name>\n        - git commit -m \"Remove submodule <name>\"\n        - Verify .gitmodules updated; if needed remove leftover config sections: git config -f .git/config --remove-section submodule.children/<name> || true\n   b) Rename a submodule path\n      - git mv children/<old> children/<new>; update .gitmodules path entry; git submodule sync --recursive; git add .gitmodules; git commit.\n   c) Migrate an existing folder to a submodule (history preserved)\n      - Option A (subtree split):\n        - git subtree split -P children/<name> -b export/<name>\n        - Create new repo; push: git push <new-url> export/<name>:main\n        - Remove folder; add as submodule per step 3a.\n      - Option B (git filter-repo) with equivalent steps if allowed.\n5) CI/CD considerations\n   - GitHub Actions:\n     - Use actions/checkout@v4 with: submodules: recursive, fetch-depth: 0; set ssh-key or token for private submodules.\n     - Example:\n       - uses: actions/checkout@v4\n         with:\n           submodules: recursive\n           fetch-depth: 0\n           ssh-key: ${{ secrets.DEPLOY_KEY }}\n   - GitLab CI:\n     - before_script: git submodule sync --recursive && git submodule update --init --recursive\n     - Ensure GIT_SSH_COMMAND or CI_JOB_TOKEN auth setup.\n   - Caching strategies; pin to tags for release builds.\n6) Authentication for private submodules\n   - Recommended: SSH with org deploy keys or user keys; URL standardization using git config url.ssh://git@github.com/.insteadOf https://github.com/\n   - Alternative: HTTPS with fine-grained PAT; update Actions secrets and CI variable usage.\n7) Versioning and release management\n   - Policy: branch-tracking during development; release pinning to tags.\n   - Release process: tag child repos; update parent to tags; tag parent; changelog aggregation.\n8) Tooling, hooks, and configs\n   - Git configs: submodule.recurse=true; status.submodulesummary=1.\n   - Pre-commit hook to block committing with dirty submodules.\n   - Pre-push hook to block pushing parent with unpushed child branches.\n   - Optional helper scripts (see Phase 3) referenced here.\n9) Troubleshooting and FAQ\n   - Detached HEAD inside submodules and how to switch branch.\n   - Submodule pointer appears modified unexpectedly (explain pointers).\n   - Updating .gitmodules vs .git/config; use git submodule sync.\n   - Dealing with nested submodules.\n   - Cleaning local state: git submodule foreach --recursive git clean -fdx.\n\nPhase 3: Optional supporting assets (if in scope)\n1) scripts/submodules/add_child.sh\n   - Inputs: repo URL, path, branch; configures .gitmodules, shallow if requested.\n2) scripts/submodules/update_all.sh\n   - Loops over submodules; runs git submodule update --remote --merge; opens a branch and commits pointer bumps.\n3) scripts/submodules/check_clean.sh\n   - Exits non-zero if any submodule has uncommitted changes or unpushed commits.\n4) .githooks/\n   - pre-commit: call check_clean.sh; warn if submodule pointer changed without .gitmodules update when needed.\n   - pre-push: prevent pushes if submodules point to non-origin commits.\n5) Documentation references to these scripts and how to install hooks (core.hooksPath).\n\nPhase 4: Validation and review\n1) Dry-run the documented commands in a throwaway clone to confirm accuracy across macOS/Linux.\n2) Validate CI snippets by triggering a minimal workflow (or using local runner like act where possible).\n3) Obtain review from at least two maintainers focused on Git hygiene and CI.\n\nPhase 5: Adoption\n1) Link the new doc from README and CONTRIBUTING.\n2) Announce in team channels; include a short Quickstart snippet.\n3) Open a tracking issue for future improvements (automation, Renovate support for submodules, etc.).\n\nAcceptance criteria\n- A single, comprehensive document exists at docs/child-projects/submodules.md covering: overview, quickstart, daily workflows (add/update/develop/coordinated), maintenance (remove/rename/migrate), CI/CD, auth, versioning, tooling, troubleshooting.\n- All command sequences are tested and correct.\n- CI examples provided for at least GitHub Actions and GitLab CI.\n- Clear policies on branch tracking vs tagged releases and on authentication are documented.\n- Reviewed and approved by 2 maintainers.\n\nOut of scope / Risks\n- Deep automation of cross-repo PRs (may be proposed later).\n- Migration tooling beyond documented steps (use subtree/filter-repo as guidance).\n- Risk: Private submodules in CI require proper key management\u2014documented mitigations provided.\n\nEstimated effort\n- Authoring and testing: 1\u20132 days.\n- Review and polish: 0.5 day.",
      "context": [
        "docs/FILE_ORGANISATION.md",
        "docs/PROJECTS_GUIDE.md"
      ],
      "acceptance": [
        "A Markdown document exists at docs/PROJECTS_GUIDE.md describing how child projects under the projects/ directory are managed as git submodules.",
        "docs/FILE_ORGANISATION.md is updated to include this file",
        "The document includes an Overview section explaining the purpose of the projects/ folder and that each child project is a git submodule.",
        "The document provides instructions for cloning the repository with submodules using git clone --recurse-submodules, and for initializing submodules in an existing clone using git submodule init and git submodule update (including the --init --recursive variant).",
        "The document explains how to add a new child project as a submodule under projects/<name> using git submodule add -b <branch> <url> projects/<name>, and explicitly mentions committing both .gitmodules and the submodule pointer update in the superproject.",
        "The document explains how to update submodules to newer commits using either git submodule update --remote [--recursive] or by entering the submodule and pulling, then committing the pointer bump in the superproject. It includes examples of git submodule foreach for bulk operations.",
        "The document explains how to switch the tracked branch for a submodule via git config -f .gitmodules submodule.projects/<name>.branch <branch> and notes committing .gitmodules.",
        "The document explains how to remove a child project submodule, including the steps: git submodule deinit -f projects/<name>, git rm -f projects/<name>, and removing the .git/modules/projects/<name> directory, and notes that .gitmodules is updated and committed accordingly.",
        "The document contains a Common pitfalls section that explicitly mentions: detached HEAD in submodules, uncommitted changes in submodules, mixing SSH and HTTPS URLs, forgetting to commit .gitmodules, not committing the submodule pointer update, needing git submodule sync when URLs change, and ensuring CI uses --init --recursive.",
        "The document contains a CI/CD notes section showing recommended commands to fetch submodules in automation: git clone --recurse-submodules and/or git submodule update --init --recursive.",
        "The document includes a Troubleshooting section with git submodule sync (preferably with --recursive) and git submodule status usage.",
        "The document includes a Quick reference or cheat sheet that summarizes the most common commands for clone/init, add, update, switch branch, remove, and status.",
        "All examples use paths under projects/ and illustrate projects/<name> for submodules, and the document makes clear that changes inside a submodule should be committed within the submodule and then the superproject pointer updated and committed.",
        "The document references and demonstrates the following commands at least once: git clone --recurse-submodules; git submodule init; git submodule update; git submodule update --init --recursive; git submodule add -b; git submodule update --remote; git submodule foreach; git submodule status; git config -f .gitmodules submodule.projects/<name>.branch <branch>; git submodule deinit -f; git rm -f projects/<name>; rm -rf .git/modules/projects/<name>; git submodule sync.",
        "The document discusses authentication schemes (SSH vs HTTPS) and warns about mixing them across submodules and CI."
      ]
    },
    {
      "id": "3.2",
      "status": "+",
      "title": "Update .gitignore to ignore projects/ directory and contents",
      "description": "Add .gitignore rules so the projects/ folder (which contains child projects as git submodules) and all files within it are ignored by the main repository, while ensuring submodule tracking via .gitmodules and gitlinks remains intact.",
      "plan": "Implementation plan for feature 3.1: Update .gitignore to ignore projects/ directory and contents\n\n1) Preparation\n- Confirm the repository uses a top-level directory named \"projects\" for child projects.\n- Decide whether the repository must keep an empty projects/ directory tracked (e.g., via a .gitkeep). If not required, ignore everything. If required, add an exception for a single placeholder file.\n\n2) Update .gitignore\n- Locate the root .gitignore file. If it does not exist, create it at the repository root.\n- Open .gitignore and add a new section (avoid duplicating existing rules):\n  # Ignore child projects directory\n  /projects/\n- Notes:\n  - Use forward slashes; Git ignores are POSIX-style regardless of OS.\n  - The leading slash scopes the rule to the repository root so only the top-level projects/ is ignored.\n\n3) Optional: keep a placeholder tracked (only if needed)\n- If the team requires the directory to exist in the repo while ignoring its contents, add an exception rule under the above lines:\n  !/projects/.gitkeep\n- Do NOT add this exception unless we also intend to commit a projects/.gitkeep file in a separate task. This feature only adjusts .gitignore.\n\n4) Validate locally\n- Create a temporary file for verification: echo \"test\" > projects/_ignore_me.txt\n- Run: git status\n  - Expected: projects/_ignore_me.txt should not appear in the status output.\n- If an exception for .gitkeep was added in step 3, create an empty projects/.gitkeep and run: git add projects/.gitkeep\n  - Expected: .gitkeep is tracked while all other files under projects/ remain ignored.\n- Optionally run: git check-ignore -v projects/_ignore_me.txt to confirm the rule and source line.\n\n5) Edge cases and conflicts\n- Ensure there are no un-ignore rules (e.g., !/projects/*) elsewhere in .gitignore that would counteract this.\n- If prior rules existed for projects/, consolidate into a single clear rule to avoid confusion.\n\n6) Documentation\n- Update developer docs/README (in a separate docs task if necessary) to clarify that all child projects live under projects/ and are ignored by default.\n\n7) Acceptance criteria\n- .gitignore contains an entry that ignores the top-level projects/ directory and all its contents.\n- Creating files under projects/ does not show them in git status.\n- No unintended files outside projects/ are affected.\n\n8) Rollback plan\n- If needed, remove the /projects/ rule from .gitignore and commit the change.\n- Run git rm -r --cached projects/ to re-track the directory and its contents if previously ignored.",
      "context": [
        ".gitignore",
        ".gitmodules",
        "docs/FILE_ORGANISATION.md"
      ],
      "acceptance": [
        ".gitignore exists at the repository root.",
        ".gitignore includes an ignore rule that ignores the entire projects/ directory and its contents (accepted patterns: 'projects/', '/projects/', 'projects/**', or '/projects/**').",
        ".gitignore explicitly unignores the .gitmodules file to keep submodule tracking intact (accepted patterns: '!.gitmodules' or '!/.gitmodules').",
        ".gitignore does not contain a rule that directly ignores .gitmodules (e.g., '.gitmodules' or '/.gitmodules')."
      ]
    },
    {
      "id": "3.3",
      "status": "+",
      "title": "Helper scripts for submodule initialization and management",
      "description": "Add simple, portable shell scripts to streamline submodule initialization, syncing, and adding new child projects under the projects/ folder.",
      "plan": "Feature: Helper scripts for submodule initialization and management (ID: 3.3)\n\nObjective\n- Provide a robust, cross-platform (macOS/Linux/Windows) set of helper scripts to initialize, update, inspect, add, remove, and otherwise manage Git submodules used for the child projects structure.\n- Make routine operations one-liners, standardize .gitmodules configuration, enforce reproducibility, and integrate with CI.\n\nDeliverables\n- Scripts (Bash + PowerShell) under scripts/projects/:\n  - bootstrap.(sh|ps1): Initialize and sync all submodules recursively.\n  - update.(sh|ps1): Update submodules to recorded commits (default) or fetch latest from remotes with flags.\n  - status.(sh|ps1): Summarize submodule state; optional JSON output for CI.\n  - add.(sh|ps1): Add a new submodule with consistent configuration.\n  - remove.(sh|ps1): Cleanly remove a submodule and its metadata.\n  - foreach.(sh|ps1): Safe wrapper to run commands across submodules with filtering.\n  - switch-branches.(sh|ps1): Align all submodules to a branch, tag, or recorded commit.\n  - lock.(sh|ps1): Generate/verify a lock manifest with submodule commit SHAs and metadata.\n  - ci-prepare.(sh|ps1): Helper for CI environments to ensure submodules are ready (with caching support hints).\n- Configuration and documentation:\n  - scripts/submodules/README.md: Usage guide, examples, troubleshooting.\n  - scripts/submodules/.env.example: Optional environment variable overrides.\n  - Update repository root README or CONTRIBUTING to reference scripts.\n  - Optional .githooks installation script to prevent committing dirty submodules.\n- CI examples:\n  - .github/workflows/submodules.yml snippet or docs for integrating bootstrap + status checks.\n\nAssumptions and Constraints\n- Git version >= 2.28 recommended (for consistent behavior); scripts will detect and warn for older versions.\n- No external dependencies beyond Git, Bash (Unix), and PowerShell (Windows). JSON output will be handcrafted to avoid jq dependency.\n- Support nested submodules via --recursive where appropriate.\n\nDirectory Structure\n- scripts/submodules/\n  - bootstrap.sh, bootstrap.ps1\n  - update.sh, update.ps1\n  - status.sh, status.ps1\n  - add.sh, add.ps1\n  - remove.sh, remove.ps1\n  - foreach.sh, foreach.ps1\n  - switch-branches.sh, switch-branches.ps1\n  - lock.sh, lock.ps1\n  - ci-prepare.sh, ci-prepare.ps1\n  - README.md\n  - .env.example\n\nConventions & Defaults\n- .gitmodules standardization:\n  - submodule.<name>.update = checkout (avoid rebase/merge surprises)\n  - submodule.<name>.fetchRecurseSubmodules = true\n  - submodule.<name>.shallow = true for CI speed (configurable flag)\n- Default behavior:\n  - bootstrap: sync and checkout recorded commits, recursive, jobs = number of cores (configurable via SUBMODULE_JOBS)\n  - update: no remote fast-forward by default; optional --remote to move fast-forward to remote HEAD of tracked branch.\n  - status: display commit, branch (if any), HEAD detached/dirty, ahead/behind; exit non-zero if dirty unless --allow-dirty.\n  - lock: generates scripts/submodules/submodules.lock.json with path, name, commit, branch, remote URL, and timestamp; verify checks against working tree and recorded commits.\n- Environment variables to control behavior:\n  - SUBMODULE_JOBS (default: min(8, nproc))\n  - SUBMODULE_REMOTE (true/false default false)\n  - SUBMODULE_SHALLOW (true/false default true)\n  - SUBMODULE_ASSUME_YES (for non-interactive remove/add)\n\nImplementation Steps\n1) Scaffolding\n- Create scripts/submodules/ directory and placeholder files for all scripts with shebangs, usage text, and set -euo pipefail (Bash). In PowerShell, use strict mode and proper error handling.\n- Add .env.example with documented variables.\n- Add README.md skeleton.\n\n2) bootstrap.(sh|ps1)\n- Behavior:\n  - Validate Git repo and .gitmodules existence; if missing, log and exit 0.\n  - git submodule sync --recursive\n  - Configure fetchRecurseSubmodules=true at repo level if not set.\n  - Determine jobs: $SUBMODULE_JOBS or cores.\n  - git submodule update --init --recursive --jobs N\n  - If SUBMODULE_SHALLOW=true, attempt shallow initialization:\n    - git -c submodule.<name>.shallow=true submodule update --init --depth 1 (note: depth 1 may not work for recorded commits; fallback without depth on failure)\n- Edge cases:\n  - If recorded commit is not reachable in shallow fetch, automatically retry without shallow.\n  - Handle nested submodules recursively.\n- Logging: clear start/end messages, durations.\n- Exit codes: non-zero on failure; zero on success.\n\n3) update.(sh|ps1)\n- Flags:\n  - --remote: update submodules to latest commit on their tracked branch (git submodule update --remote)\n  - --all: operate on all submodules (default); optional positional list to limit paths\n  - --recursive: propagate into nested submodules\n  - --jobs N: override parallelism\n  - --commit: after updates, create a single commit in superproject recording new gitlinks (default true unless --no-commit)\n  - --no-commit: do not commit changes\n  - --message \"msg\": custom commit message\n- Implementation:\n  - Parse args; compute git submodule update args accordingly\n  - Ensure submodule branches are configured (submodule.<name>.branch). If missing but --remote provided, default to main/master detection or warn and skip.\n  - Run git submodule update [--remote] [--init] --recursive --jobs N [paths]\n  - Detect dirty submodules after update; show diff summary\n  - If --commit, run git add .gitmodules and submodule paths with changes, then create a single commit with message like \"chore(submodules): update\"\n- Edge cases: detached HEAD inside submodules when using --remote; consider switching to branch temporarily if needed.\n\n4) status.(sh|ps1)\n- Flags: --json for machine output; --summary (default); --recursive; --fail-on-dirty (default true)\n- Implementation:\n  - For each submodule (git config --file .gitmodules --get-regexp path):\n    - Get recorded commit from superproject index (git ls-tree HEAD <path>)\n    - Get working commit (git -C <path> rev-parse HEAD)\n    - Check dirty state (git -C <path> status --porcelain)\n    - Determine branch (git -C <path> symbolic-ref --short -q HEAD), or note detached\n    - Ahead/behind vs remote (if branch set and upstream exists)\n  - Print human-readable table; for --json output a JSON array with objects {name,path,recordedCommit,headCommit,branch,detached,dirty,ahead,behind,remoteUrl}\n  - Exit non-zero if any dirty and --fail-on-dirty\n\n5) add.(sh|ps1)\n- Usage: add <url> <path> [--name <name>] [--branch <branch>] [--shallow]\n- Steps:\n  - Validate url and path (path within repo, not existing file)\n  - git submodule add [-b branch] --name name URL PATH\n  - Enforce .gitmodules conventions (update=checkout, fetchRecurseSubmodules=true, shallow=true if requested)\n  - git add .gitmodules PATH && git commit -m \"chore(submodules): add <name>\"\n- Edge: If branch not provided attempt to detect remote default branch.\n\n6) remove.(sh|ps1)\n- Usage: remove <path> [--yes]\n- Steps:\n  - Confirm removal (unless --yes or SUBMODULE_ASSUME_YES)\n  - git submodule deinit -f PATH\n  - git rm -f PATH (removes from index and working tree)\n  - Remove section from .gitmodules: git config -f .gitmodules --remove-section submodule.<name>\n  - git add .gitmodules && rm -rf .git/modules/<path> && git commit -m \"chore(submodules): remove <name>\"\n- Safety: Validate path is a configured submodule.\n\n7) foreach.(sh|ps1)\n- Usage: foreach [--recursive] [--filter name|path regex] -- <command>\n- Wrapper over git submodule foreach; add filtering by name/path via pre-selection of submodule list.\n\n8) switch-branches.(sh|ps1)\n- Usage:\n  - switch-branches --to-branch <branch>\n  - switch-branches --detach (reset all submodules to recorded commits)\n- Implementation:\n  - For each submodule:\n    - If --to-branch: fetch, check if branch exists; checkout or create tracking; pull --ff-only\n    - If --detach: git -C <path> checkout --detach <recordedCommit>\n  - Option --commit to record updated gitlinks in superproject\n- Edge: handle protected or diverged branches (warn and skip).\n\n9) lock.(sh|ps1)\n- Behavior:\n  - lock generate: Produce scripts/submodules/submodules.lock.json containing an array of objects for each submodule: name, path, commit, branch (if any), remoteUrl, timestamp, superprojectCommit.\n  - lock verify: Compare lockfile to working tree commits and remote URLs; fail if mismatched.\n- Flags: --verify, --generate (default), --output <file>\n\n10) ci-prepare.(sh|ps1)\n- Logic:\n  - If repo cloned with --recurse-submodules: run bootstrap to sync and ensure recorded commits\n  - Else: run bootstrap from scratch\n  - Print caching tips (e.g., cache .git/modules and submodule directories if feasible)\n\n11) Documentation (README.md)\n- Overview and rationale\n- Prerequisites and Git version notes\n- Quick start: scripts/submodules/bootstrap.sh; Windows PowerShell commands\n- Detailed usage for each script, with examples\n- CI integration example (GitHub Actions): checkout with submodules: recursive; run ci-prepare and status --json\n- Troubleshooting: detached HEAD, shallow fetch failures, mismatched URLs, Windows execution policy (Set-ExecutionPolicy RemoteSigned)\n\n12) Quality and Safety\n- Implement common helpers: colored output (optional), verbose mode (-v), and robust error handling.\n- Ensure scripts only operate within the current Git repo; guard against paths outside repo root.\n- Ensure idempotency of bootstrap and status.\n- Provide clear exit codes for CI usage.\n\n13) Acceptance Criteria\n- bootstrap initializes a fresh clone with nested submodules, handling shallow fallback automatically.\n- update --remote updates to latest for all submodules with a single superproject commit.\n- status outputs accurate table and valid JSON with --json; exits non-zero when dirty.\n- add and remove create appropriate commits and maintain .gitmodules consistency.\n- switch-branches switches all submodules to a target branch or detaches to recorded commit.\n- lock generate/verify works and detects mismatches.\n- All scripts work on macOS/Linux (Bash) and Windows (PowerShell) with identical semantics.\n\n14) Test Plan\n- Create a local test harness script that initializes a temporary repo with two nested submodules, commits, and branches.\n- Test scenarios:\n  - Fresh bootstrap with shallow=true; fallback on missing commit\n  - update --remote on submodules tracking main\n  - status dirty and clean cases; verify JSON parse\n  - add/remove round-trip; ensure .gitmodules cleaned\n  - switch-branches to branch and detach back to recorded commit\n  - lock generate and verify failure after manual change\n  - Windows PowerShell smoke test for all scripts\n\n15) Rollout\n- Implement Bash scripts first, mirror functionality in PowerShell with consistent flags.\n- Add docs and examples.\n- Wire into CI: add a workflow job invoking bootstrap and status --json; fail on dirty.\n- Announce usage guidance to the team and migrate any legacy submodule scripts to these new helpers.\n",
      "context": [
        "docs/FILE_ORGANISATION.md",
        "tasks/3/task.json",
        "tasks/3/tests/test_3_3.py"
      ],
      "acceptance": [
        "Provide three POSIX shell scripts under scripts/projects/: scripts/projects/submodules-init.sh, scripts/projects/submodules-sync.sh, scripts/projects/project-add.sh.",
        "All scripts must be portable POSIX sh: use shebang '#!/usr/bin/env sh', avoid bash-specific constructs (no [[ ]], arrays, 'function' keyword), and pass 'sh -n' syntax check.",
        "All scripts must be executable (chmod +x).",
        "scripts/projects/submodules-init.sh:",
        "- When run with no arguments inside a git repository, it must execute 'git submodule sync --recursive' followed by 'git submodule update --init --recursive', and exit 0.",
        "- If the repository has no submodules (.gitmodules missing or empty), it must exit 0 and print a helpful message indicating no submodules to initialize.",
        "- If run outside of a git repository, it must exit with a non-zero status and print a clear error message.",
        "- It must support -h/--help, printing usage to stdout and exiting 0.",
        "scripts/projects/submodules-sync.sh:",
        "- When run with no arguments inside a git repository, it must execute 'git submodule sync --recursive' and exit 0.",
        "- If the repository has no submodules (.gitmodules missing or empty), it must still exit 0 with a helpful message.",
        "- If run outside of a git repository, it must exit non-zero with a clear error message.",
        "- It must support -h/--help, printing usage to stdout and exiting 0.",
        "scripts/projects/project-add.sh:",
        "- Usage: 'project-add.sh <repo_url> <name> [--branch BRANCH]'.",
        "- Must be run inside a git repository; if not, exit non-zero with a clear error message.",
        "- Must ensure the 'projects/' directory exists (create it if missing).",
        "- Must validate that <name> does not contain path separators or traversal components and that 'projects/<name>' does not already exist; otherwise exit non-zero with a clear error message.",
        "- Must add the given repository as a git submodule at 'projects/<name>' using 'git submodule add' and the provided branch if '--branch' is specified.",
        "- On success, '.gitmodules' must contain an entry for 'projects/<name>' with the correct URL, and 'projects/<name>' should be populated (cloned).",
        "- A subsequent attempt to add the same <name> must fail with a non-zero exit and an explanatory message.",
        "No script may depend on non-standard tools beyond POSIX sh and git; they must work on Linux and macOS (avoid non-portable utilities like 'readlink -f').",
        "All scripts must print concise, readable usage text including a one-line description and examples for -h/--help."
      ]
    },
    {
      "id": "3.4",
      "status": "-",
      "title": "Split 3.3 into 3 separate tasks - 1 for each script",
      "description": "Use the `create_feature` tool to do so",
      "plan": "Objective: Split feature 3.3 into three separate tasks, one for each script, to enable parallel development, clearer ownership, and targeted testing/deployment.\n\nHigh-level steps:\n1) Inventory 3.3 scope\n   - Review the 3.3 specification and list the three scripts (names, goals, inputs/outputs, runtime contexts, dependencies, and expected side effects).\n   - Confirm any shared utilities or schemas used across scripts to avoid duplication.\n\n2) Define task boundaries\n   - Script A: Structure generation script (creates child projects and relationships from configuration/source-of-truth). \n   - Script B: Migration/backfill script (moves or backfills existing data into new child structure while preserving integrity and auditability).\n   - Script C: Post-migration validation & cleanup script (verifies referential integrity, cleans orphans/inconsistencies, and produces reports).\n   - For each, capture: scope, inputs/outputs, non-functional requirements (performance, idempotency, observability), rollback strategy, and acceptance criteria.\n\n3) Create three features (one per script)\n   - Create Feature: 3.3A \u2013 Script: Child projects structure generation.\n   - Create Feature: 3.3B \u2013 Script: Migrate/backfill into child project structure.\n   - Create Feature: 3.3C \u2013 Script: Post-migration validation and cleanup.\n   - Each feature to include: detailed plan, milestones, test strategy, rollout steps, and acceptance criteria.\n\n4) Linkage and traceability\n   - In each new feature, reference original 3.3 and parent initiative (ID: 3) to maintain traceability.\n   - Note any shared schemas or modules; define a common utility module if needed.\n\n5) Deprecate/adjust original 3.3 item\n   - Mark 3.3 as split into 3.3A/3.3B/3.3C; migrate any existing subtasks to the relevant new features.\n   - Update roadmap timelines and owners per new feature.\n\n6) Estimation and ownership\n   - Provide rough estimates per feature with a buffer for integration testing.\n   - Assign provisional owners and reviewers (to be set by PM/lead).\n\n7) Definition of Done (for 3.4 \u2013 the split)\n   - Three new features created with detailed plans and acceptance criteria.\n   - Cross-references to 3.3 present.\n   - Original 3.3 annotated as split.\n   - Risks and dependencies captured (e.g., data access, migration window, rollback).\n\nRisks & Mitigations:\n- Unclear script boundaries: Mitigate by documenting inputs/outputs and ensuring idempotency and clear side effects.\n- Data integrity issues during migration: Enforce dry runs, checksums, and post-validation gates.\n- Rollback complexity: Define reversible steps and pre-migration backup strategy.\n",
      "context": [
        "docs/FILE_ORGANISATION.md"
      ],
      "acceptance": []
    },
    {
      "id": "3.5",
      "status": "-",
      "title": "3.3A \u2013 Script: Child projects structure generation",
      "description": "Create a script that generates the new child projects structure (entities, relationships, and indexes) based on the agreed schema and configuration outlined in feature 3.3. This script must be idempotent, support dry-run mode, and provide comprehensive logging/metrics.",
      "plan": "Scope:\n- Read configuration/source-of-truth defining child projects structure (e.g., mapping rules, hierarchical relationships, naming conventions).\n- Create child project entities and relationships without duplications (idempotent operations).\n- Prepare required indexes/constraints.\n- Support dry-run and apply modes with detailed diffs and summary reports.\n\nImplementation steps:\n1) Requirements & design\n   - Confirm schema for child projects (tables/collections, fields, constraints).\n   - Define config file format and validation (JSON/YAML schema validation).\n   - Define idempotency strategy (upsert patterns, unique constraints, checksums).\n2) Boilerplate & scaffolding\n   - Set up script project structure, configuration loader, and CLI arguments (e.g., --dry-run, --apply, --batch-size, --log-level, --output-report).\n   - Establish logging, metrics, and error handling patterns.\n3) Core functionality\n   - Parse config; compute desired state for child projects and relationships.\n   - Diff current vs desired state; generate operations plan (create/update/no-op) respecting idempotency.\n   - Implement execution engine with batching and retry policies.\n4) Observability & safety\n   - Implement verbose logging, progress metrics, and summary report (created/updated/skipped/failed counts).\n   - Add guardrails (confirmation prompts for apply mode, scope filters).\n5) Testing\n   - Unit tests for config parsing, diffing logic, and idempotency.\n   - Integration tests against a test database/sample dataset.\n   - Dry-run snapshots to validate diffs.\n6) Documentation\n   - Usage guide with examples; config spec; troubleshooting.\n7) Rollout\n   - Package script; define runtime prerequisites; add to CI pipeline for basic lint/tests.\n\nAcceptance criteria:\n- Given a valid config, dry-run outputs deterministic diffs and no changes applied.\n- Apply mode creates/updates child projects and relationships idempotently (re-running yields no further changes).\n- Indexes/constraints are created or verified.\n- Logs, metrics, and a summary report are produced.\n- All unit and integration tests pass.\n",
      "context": [],
      "acceptance": []
    },
    {
      "id": "3.6",
      "status": "-",
      "title": "3.3B \u2013 Script: Migrate/backfill into child project structure",
      "description": "Create a migration/backfill script to move existing data into the new child projects structure defined in feature 3.3, ensuring data integrity, auditability, and minimal downtime.",
      "plan": "Scope:\n- Analyze current data model and map to the new child projects structure.\n- Migrate/backfill existing records into child entities while preserving relationships and lineage.\n- Provide checkpointing, resumability, and rollback strategy.\n\nImplementation steps:\n1) Pre-migration analysis\n   - Define field mapping, transformation rules, and conflict resolution policies.\n   - Identify dependencies and pre-checks (indexes, constraints, capacity, maintenance window).\n   - Define backup/export strategy for rollback.\n2) Framework & scaffolding\n   - CLI options: --dry-run, --execute, --start-from-checkpoint, --limit, --concurrency, --rollback.\n   - Common libraries: logging, metrics, retry/backoff, checkpoint storage.\n3) Migration engine\n   - Batch processing with transactional boundaries where possible.\n   - Data transformation and validation per record.\n   - Conflict handling (duplicates, missing references) with policy-driven decisions and quarantine lists.\n   - Checkpointing/resume to handle interruptions safely.\n4) Observability & safety\n   - Detailed logs, progress metrics, and anomaly reports.\n   - Throttling and concurrency controls to mitigate load.\n   - Dry-run mode that simulates transformations and estimates runtime impact.\n5) Testing\n   - Unit tests for transformation rules and conflict resolution.\n   - Integration tests against representative data samples.\n   - Backward-compatibility checks where applicable.\n6) Rollback\n   - Implement rollback actions or restore-from-backup steps with verification.\n7) Documentation\n   - Runbook: pre-checks, execution steps, monitoring, rollback, and post-checklist.\n\nAcceptance criteria:\n- Dry-run produces a detailed plan without mutating data.\n- Migration applies transformations correctly, maintains referential integrity, and produces audit logs.\n- Supports resume after interruption without data duplication or loss.\n- Rollback procedure validated in a non-prod environment.\n- Tests pass and performance meets agreed SLOs.\n",
      "context": [],
      "acceptance": []
    },
    {
      "id": "3.7",
      "status": "-",
      "title": "3.3C \u2013 Script: Post-migration validation and cleanup",
      "description": "Create a script to validate the new child projects structure post-migration and perform safe cleanup of obsolete/duplicate/orphaned data. Provide comprehensive reporting for sign-off.",
      "plan": "Scope:\n- Validate referential integrity and schema conformance.\n- Detect and report orphans, duplicates, and inconsistencies.\n- Perform safe cleanup actions with dry-run and approval gates.\n\nImplementation steps:\n1) Validation design\n   - Define validation queries/checks (integrity, counts, invariants, spot-checks).\n   - Establish thresholds and pass/fail criteria.\n2) Scaffolding\n   - CLI options: --dry-run, --validate-only, --cleanup, --report-path, --subset-filter.\n   - Shared logging/metrics/reporting utilities.\n3) Validation engine\n   - Implement checks for: missing relationships, count deltas vs baselines, schema mismatches.\n   - Generate a structured report (machine-readable + human summary) with findings and recommendations.\n4) Cleanup engine\n   - Implement reversible cleanup actions for orphans/obsolete records with staging and confirmation steps.\n   - Ensure idempotency and safety checks before deletes/updates.\n5) Observability\n   - Metrics on validation coverage, failures, and cleanup actions executed/skipped.\n6) Testing\n   - Unit tests for each validation rule and cleanup path.\n   - Integration tests simulating typical inconsistency scenarios.\n7) Documentation\n   - Runbook for validation, interpreting reports, and executing cleanup safely.\n\nAcceptance criteria:\n- Validation report covers all defined checks and clearly indicates pass/fail with counts.\n- Dry-run of cleanup lists intended actions without side effects.\n- Apply mode performs only approved actions with logs and auditability.\n- All tests pass; validations gate production sign-off.\n",
      "context": [],
      "acceptance": []
    }
  ]
}