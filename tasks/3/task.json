{
  "id": 3,
  "status": "-",
  "title": "New child projects structure",
  "description": "Create a new structure for child projects that stems from this project. This will be done by creating a new repository for each child project. Each child project is linked backed to this projct via git-submodules so that all the child projects are automatically updated whenever this project updates. This project drives the child projects and then the child projects can also be cloned independently if needed and will drive their own implementation work.",
  "features": [
    {
      "id": "3.1",
      "status": "+",
      "title": "Script: Child projects structure generation and other various utils and helpers",
      "description": "The script generates the new child projects within the projects/ folder. It sets up a folder with an initial empty task so that it's possible to start planning the feature out. It also creates a git repository for it and links it via submodules to this project.",
      "plan": "1. In 'scripts/child_project_utils.py', add imports for required modules: import json, import shutil, import os.\n2. Add a new argument to the argparse parser: parser.add_argument('--init-task-id', type=int, default=None, help='Optional task ID to copy and renumber from tasks/<id>/ for the child project's initial task.').\n3. Remove the INITIAL_TASK_CONTENT constant and the line that writes to initial_task_path.\n4. After creating the tasks_dir, add logic to set up the initial task:\n   - target_dir = tasks_dir / '1'\n   - target_dir.mkdir(exist_ok=True)\n   - if args.init_task_id is not None:\n     - source_dir = Path(f'tasks/{args.init_task_id}')\n     - if not source_dir.exists():\n       - print(f'Error: Task {args.init_task_id} does not exist.', file=sys.stderr)\n       - sys.exit(1)\n     - shutil.copytree(source_dir, target_dir)\n     - task_file = target_dir / 'task.json'\n     - with open(task_file, 'r', encoding='utf-8') as f:\n       - task = json.load(f)\n     - old_id = task['id']\n     - task['id'] = 1\n     - for feature in task.get('features', []):\n       - if '.' in feature['id']:\n         - base, sub = feature['id'].split('.', 1)\n         - if base == str(old_id):\n           - feature['id'] = f'1.{sub}'\n     - with open(task_file, 'w', encoding='utf-8') as f:\n       - json.dump(task, f, indent=2)\n     - tests_dir = target_dir / 'tests'\n     - if tests_dir.exists():\n       - for file in tests_dir.iterdir():\n         - if file.is_file() and file.name.startswith(f'test_{old_id}_'):\n           - new_name = f'test_1_' + file.name[len(f'test_{old_id}_'):]\n           - os.rename(file, tests_dir / new_name)\n   - else:\n     - example_path = Path('docs/tasks/task_example.json')\n     - if not example_path.exists():\n       - print('Error: Example task file does not exist.', file=sys.stderr)\n       - sys.exit(1)\n     - task_file = target_dir / 'task.json'\n     - shutil.copy(example_path, task_file)\n     - with open(task_file, 'r', encoding='utf-8') as f:\n       - task = json.load(f)\n     - old_id = task['id']\n     - task['id'] = 1\n     - for feature in task.get('features', []):\n       - if '.' in feature['id']:\n         - base, sub = feature['id'].split('.', 1)\n         - if base == str(old_id):\n           - feature['id'] = f'1.{sub}'\n     - with open(task_file, 'w', encoding='utf-8') as f:\n       - json.dump(task, f, indent=2)\n5. Optionally, create an empty 'tests/' directory in target_dir for the default case: (target_dir / 'tests').mkdir(exist_ok=True), but only if desired to match structure.\n6. Ensure the git add . in the child repo includes the new files.",
      "context": [
        "docs/FILE_ORGANISATION.md",
        "docs/PROJECTS_GUIDE.md",
        "scripts/child_project_utils.py",
        "docs/tasks/task_format.py",
        "docs/tasks/task_example.json"
      ],
      "acceptance": [
        "A CLI entry point exists to generate a child project: scripts/child_project_utils.py. It accepts at minimum: project_name (required), and optionally: description, repo_url (for remote origin), path (defaulting to projects/), and --task-id <int> to seed from an existing task folder.",
        "When invoked with a new project_name, the script creates a directory at projects/{project_name}. If the directory already exists, the script exits with a non-zero code and a clear error message without modifying existing contents.",
        "Inside the new child project, the script creates a minimal structure including: README.md with the provided name/description, a .gitignore with typical Python/Node/temp patterns, and a tasks/1/task.json file. By default, tasks/1/task.json is populated from docs/tasks/task_example.json (valid JSON).",
        "If --repo-url is provided, it is set as the origin remote in the child project's git repo.",
        "If --task-id <id> is provided, the entire folder tasks/{id}/ from the superproject is copied into the child project as tasks/1/. All references to the original id are rewritten to 1, at minimum: task.json's top-level id becomes 1, and each feature id prefix is rewritten so it starts with '1.' with the original feature suffix preserved.",
        "The script initializes a new git repository inside the child project directory: a .git/ exists, an initial commit includes the scaffolded files, and 'git status' is clean after the commit.",
        "The root repository is updated to include the new child project as a git submodule at projects/{project_name}. The .gitmodules file is updated accordingly with the correct path and URL (repo_url if provided; otherwise a local path URL is acceptable).",
        "Re-running the script for the same project_name fails fast: it is idempotent, exits non-zero with a clear message and does not alter existing submodule configuration or filesystem state.",
        "The script provides a --dry-run option that prints planned actions (paths to create, git commands to run) and makes no filesystem or git changes when used.",
        "The script returns exit code 0 on success and non-zero on failure; errors include actionable messages (e.g., missing git, invalid name, non-empty target path).",
        "A help/usage message is available via -h/--help describing arguments, options (including --task-id), examples, and behavior."
      ]
    },
    {
      "id": "3.2",
      "status": "+",
      "title": "Document script guide",
      "description": "Create clear documentation detailing how the script is used (step-by-step guide to get everything working ASAP) and how to use git submodules in the main project (also as short and concise step-by-step guide for this as possible).",
      "plan": "Implementation plan for Feature 3.2: Document script guide and git submodules (addressing --task-id)\n\n1) Update docs/PROJECTS_GUIDE.md to include a clear Quick Start section\n   - Add a new \"Quick Start\" subsection near the top with two concise checklists:\n     a) Create a child project with the script (minimal steps):\n        - Ensure Git and Python 3 are installed.\n        - From repo root: python3 scripts/child_project_utils.py <project_name> [--repo-url <url>] [--task-id <id>]\n        - Commit submodule in superproject: git add .gitmodules projects/<project_name> && git commit -m \"Add submodule projects/<project_name>\"\n        - (Optional) Push child project: cd projects/<project_name> && git push origin main && cd -\n     b) Work with submodules (minimal):\n        - Clone with submodules: git clone --recurse-submodules <url>\n        - Initialize later if needed: git submodule update --init --recursive\n        - Update to latest tracked branch: git submodule update --remote projects/<name> && git add projects/<name> && git commit -m \"Bump submodule\"\n\n2) Expand the \"Creating a New Child Project Using child_project_utils.py\" section with a Script Options block\n   - Add an explicit \"Script options\" list with short descriptions:\n     - --description / -d: README blurb for the child project.\n     - --repo-url / -r: Set remote origin of the child repo (SSH/HTTPS).\n     - --path / -p: Parent directory for the project (default: projects/).\n     - --task-id: Seed the child project from the superproject's tasks/{id}/ into tasks/1/ and rewrite task.json IDs to start at 1.\n     - --dry-run: Print actions without changing anything.\n\n3) Document --task-id behavior clearly\n   - Add a dedicated sub-subsection: \"What --task-id does\" with bullets:\n     - Copies tasks/{id}/ from the superproject into projects/<name>/tasks/1/.\n     - Rewrites task.json IDs:\n       - Top-level task.id becomes 1.\n       - Each feature.id with a dot preserves its suffix but is prefixed with \"1.\" (e.g., 7.3 -> 1.3). IDs without a dot are unchanged.\n     - Fails with a clear error if tasks/{id}/ does not exist.\n   - Provide an example command:\n     - python3 scripts/child_project_utils.py my-seeded-proj --task-id 7\n   - Contrast with behavior when --task-id is not used:\n     - The script seeds tasks/1/task.json from docs/tasks/task_example.json.\n\n4) Make the step-by-step for the script explicit\n   - In the \"Step-by-Step Guide to Using the Script\" list, add a step referencing --task-id as an optional parameter to seed from an existing task, with the example command provided.\n   - After script completion, remind to commit: git add .gitmodules projects/<name> && git commit -m \"Add submodule projects/<name>\"\n   - If --repo-url was provided, show pushing the child project remote (cd projects/<name>; git push origin main; cd -).\n\n5) Add a concise submodule workflow cheat sheet if not already present\n   - Verify the existing \"Quick reference / cheat sheet\" covers:\n     - clone with recurse-submodules;\n     - init/update recursively;\n     - add with -b <branch> (optional);\n     - update with --remote and commit pointer;\n     - switch tracked branch via .gitmodules and sync;\n     - remove submodule fully.\n   - If present, ensure it remains and add a short sentence in Quick Start pointing readers to it.\n\n6) Troubleshooting notes for --task-id\n   - Add a small note in Troubleshooting:\n     - If the script errors on --task-id, verify tasks/<id>/ exists in the superproject.\n     - If IDs did not update, inspect projects/<name>/tasks/1/task.json and ensure rewrite occurred; rerun or fix manually if needed.\n\n7) Acceptance checks\n   - Ensure docs/PROJECTS_GUIDE.md explicitly contains the literal flag name \"--task-id\" (hyphenated) and describes its function.\n   - Ensure there is at least one example command using --task-id.\n   - Ensure the script quick start and submodule quick steps are present and concise.\n\n8) Run repo tests\n   - Execute: python3 scripts/run_tests.py (or project-specific test runner) and fix any doc path references if tests assert existence of the new/updated docs.\n",
      "context": [
        "docs/FILE_ORGANISATION.md",
        "docs/PROJECTS_GUIDE.md",
        "scripts/child_project_utils.py"
      ],
      "acceptance": [
        "The file 'docs/PROJECTS_GUIDE.md' exists.",
        "The content mentions 'child_project_utils.py'.",
        "The content has a heading (e.g., #, ##, ###) that includes words like 'script', 'child_project_utils', or 'creating new child project'.",
        "The content contains a step-by-step list with at least 3 steps (numbered or bulleted).",
        "The content includes an example like 'python3 scripts/child_project_utils.py'.",
        "The content includes instructions with 'git submodule add', 'git submodule update --remote', and 'git submodule deinit'.",
        "The content documents the '--task-id' option (or '--task_id'), including an example invocation using it.",
        "The content clearly explains what '--task-id' does (e.g., that it seeds the child project's tasks/1 from tasks/{id} and rewrites task.json IDs to start with 1)."
      ],
      "dependencies": [
        "3.1"
      ]
    },
    {
      "id": "3.3",
      "status": "+",
      "title": "Update the orchestrator",
      "description": "The orchestrator must be able to be ran on a child project directory. The scope of changes is then tied to that child project directory. The tasks are being worked on in that directory - not this one.",
      "plan": "Implementation Plan: Orchestrator can run on a child project directory\n\n1) Introduce dual-root architecture in the orchestrator\n   - In scripts/run_local_agent.py, define:\n     - FRAMEWORK_ROOT = Path(__file__).resolve().parent.parent\n     - TARGET_ROOT: computed at runtime, defaulting to Path.cwd(), or overridden via a new CLI flag --project-dir.\n   - Rationale: All framework code and docs (agent specs, protocol examples) come from FRAMEWORK_ROOT; all task data, file I/O, and git operations must be scoped to TARGET_ROOT.\n\n2) Add CLI support for target project directory\n   - In scripts/run_local_agent.py main(), add argparse option: --project-dir type=str, help=\"Path to target project root (child repo).\"\n   - In run_orchestrator signature and call chain, accept project_dir and compute TARGET_ROOT = Path(project_dir).resolve() if provided; else TARGET_ROOT = Path.cwd().\n   - Immediately after computing TARGET_ROOT, call a new setter in task_utils to set the project base (see step 3): task_utils.set_project_root(str(TARGET_ROOT)).\n\n3) Update task_utils to be target-root aware\n   - Add a module-level variable PROJECT_ROOT in scripts/task_utils.py (default Path.cwd()).\n   - Implement set_project_root(path: str|Path) -> None to set PROJECT_ROOT.\n   - Ensure all file path operations in task_utils use PROJECT_ROOT as the base for:\n     - tasks directory discovery (tasks/, tasks/{id}/task.json)\n     - reading/writing test files under tasks/{id}/tests/\n     - developer-facing write_file paths (guard to ensure writes stay within PROJECT_ROOT)\n     - get_context(paths) resolution: resolve relative paths against PROJECT_ROOT, and accept absolute paths directly.\n     - any persistence (status updates, acceptance criteria updates, etc.) referencing files under the target repo.\n\n4) Decouple doc/context loading between framework and target project\n   - In scripts/run_local_agent.py, change all references to docs needed for prompts:\n     - PROTOCOL_EXAMPLE_PATH = FRAMEWORK_ROOT / \"docs\" / \"agent_response_example.json\"\n     - Agent doc paths (docs/AGENT_*.md, docs/FILE_ORGANISATION.md) must be resolved from FRAMEWORK_ROOT, not TARGET_ROOT.\n   - For feature-provided context files (feature.get(\"context\", [])):\n     - Resolve these using task_utils.get_context, which will now resolve relative paths against TARGET_ROOT. This allows child projects to specify their own context files.\n\n5) Scope Git operations to the target repository\n   - Initialize GitManager with str(TARGET_ROOT) rather than current working dir.\n   - Behavior:\n     - If --project-dir is set to a child repo (standalone clone), GitManager operates on that repo (checkout/pull/push as before).\n     - If --project-dir is not set, fallback behavior remains unchanged (operate on current repo copy).\n   - No changes needed to GitManager API; just pass the correct root.\n\n6) Keep sys.path and imports tied to the framework code\n   - scripts/run_local_agent.py already inserts the framework root into sys.path via __file__.\n   - Ensure this remains pointing to FRAMEWORK_ROOT so framework modules (docs.tasks.task_format, scripts.task_utils, GitManager, etc.) are importable regardless of TARGET_ROOT.\n\n7) Adjust all path usages inside run_local_agent.py to the appropriate root\n   - Replace any use of PROJECT_ROOT for docs with FRAMEWORK_ROOT.\n   - Use TARGET_ROOT for:\n     - constructing GitManager\n     - any task_utils operations\n     - any optional local path outputs (if present)\n\n8) Update run.py to support child project runs\n   - Add argparse option --project-dir.\n   - Continue to copy only the framework repository to a temp workspace as before.\n   - When --project-dir is provided, DO NOT copy that directory (to preserve child repo .git integrity). Instead, pass the original absolute path through to the orchestrator via the new CLI flag:\n     - command.extend([\"--project-dir\", abs_path_to_child_repo])\n   - Result: The orchestrator (running in the temp copy of the framework) will read/write and git-commit directly in the child repo on disk.\n\n9) Safeguards and validations\n   - In scripts/run_local_agent.py after resolving TARGET_ROOT, validate:\n     - TARGET_ROOT exists and is a directory; if not, raise and block the feature.\n     - TARGET_ROOT/tasks exists; if not, log a warning and continue (or block if tasks are required to proceed).\n   - In task_utils.write_file, enforce that all write paths remain within PROJECT_ROOT to prevent directory traversal outside the target repo.\n\n10) Backward compatibility\n   - When --project-dir is not provided, behavior remains unchanged: orchestrator uses Path.cwd() as TARGET_ROOT and FRAMEWORK_ROOT for docs.\n   - All existing tests should continue to pass.\n\n11) Minimal documentation updates\n   - Update docs/PROJECTS_GUIDE.md:\n     - Describe the dual-root model and how child projects include or reference this framework.\n     - Document the new run option with examples:\n       - python run.py --agent planner --task <id> --project-dir /path/to/child/repo\n       - Explain that git operations will apply to the child repo.\n\n12) New tests for child project mode\n   - Under tasks/{current_task_id}/tests/ create a deterministic test that:\n     - Creates a temporary directory simulating a child project with minimal structure: tasks/ containing a simple task.json and docs/ (optional).\n     - Invokes run.py with --project-dir pointing to this temp directory and agent=planner (or a trivial agent) for a controlled feature.\n     - Verifies that task_utils updates (e.g., feature plan or status) are written under the child project temp directory, not the framework workspace.\n     - Mocks or no-ops GitManager push/pull (or allow no remote) to keep tests deterministic.\n\n13) Edge cases and error handling\n   - If the child repo lacks the framework docs, ensure prompts still load from FRAMEWORK_ROOT, avoiding crashes due to missing docs in TARGET_ROOT.\n   - If a feature specifies context paths that do not exist under TARGET_ROOT, get_context should gracefully report missing files and continue.\n\n14) Implementation order\n   - Implement task_utils.set_project_root and refactor path usages there first.\n   - Implement dual-root and CLI changes in run_local_agent.py; route all calls through task_utils with TARGET_ROOT set.\n   - Update run.py to accept and forward --project-dir.\n   - Add documentation and tests.\n\n15) Acceptance criteria verification\n   - Run the orchestrator with --project-dir pointing to a sample child repo; confirm:\n     - The agent reads framework docs from this repo (FRAMEWORK_ROOT).\n     - All reads/writes, task discovery, and git operations occur within the child project directory (TARGET_ROOT).\n     - No files in the framework temp workspace are modified besides logs.\n     - Existing non-child runs still function identically.\n",
      "context": [
        "docs/FILE_ORGANISATION.md",
        "scripts/run_local_agent.py",
        "run.py"
      ],
      "acceptance": [
        "The orchestrator must use the current working directory (cwd) as its operational root (PROJECT_ROOT == cwd).",
        "When run from a child project directory (e.g., projects/<child>), the orchestrator initializes GitManager with that child directory path.",
        "From a child project directory, the orchestrator performs branch operations (checkout, pull, push) on a features/<task_id> branch using the GitManager scoped to that child directory.",
        "Agent execution can be invoked without referencing the parent repository paths when running from a child directory (i.e., orchestrator can proceed to agent execution stage without path errors).",
        "Backwards compatibility: When run from the repository root, the orchestrator still scopes Git operations to the repository root and uses the same features/<task_id> branching convention."
      ],
      "dependencies": [
        "3.1"
      ]
    },
    {
      "id": "3.4",
      "status": "-",
      "title": "The `.env` file",
      "description": "When creating a new child project the `.env` file needs to be copied to the child project but with the child repo url as `GIT_REPO_URL`",
      "plan": "",
      "context": [
        "docs/FILE_ORGANISATION.md",
        "scripts/child_project_utils.py",
        ".env"
      ],
      "acceptance": [],
      "dependencies": [
        "3.1",
        "3.2",
        "3.3"
      ]
    },
    {
      "id": "3.5",
      "status": "-",
      "title": "A `FILE_ORGANISATION.md` template is included with every child project",
      "description": "When creating a new child project, it creates a `FILE_ORGANISATION.md` document that works the same as this project's `docs/FILE_ORGANISATION.md`. It needs to explain the starting project structure. Look at the current child project's file for reference.",
      "plan": "",
      "context": [
        "docs/FILE_ORGANISATION.md",
        "projects/overseer-local/docs/FILE_ORGANISATION.md",
        "scripts/child_project_utils.py"
      ],
      "acceptance": [],
      "dependencies": [
        "3.1",
        "3.2",
        "3.3",
        "3.4"
      ]
    }
  ]
}