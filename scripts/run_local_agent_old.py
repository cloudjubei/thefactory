
import os
import re
import sys
import argparse
import subprocess
import litellm
from dotenv import load_dotenv
from git_manager import GitManager

class UnifiedEngine:
    # (The `determine_and_execute_next_action` and `_build_prompt` methods are unchanged)
    def determine_and_execute_next_action(self, model: str, context: dict) -> dict:
        messages = self._build_prompt(context)
        response_text = self._make_api_call(model, messages)
        return self._parse_response(response_text)

    def _build_prompt(self, context: dict) -> list:
        context_str = ""
        for name, content in context.items():
            context_str += f"--- START of {name} ---\n{content}\n--- END of {name} ---\n\n"

        system_prompt = "You are an autonomous AI agent expert in software engineering and specification-driven development. Your goal is to advance the project by completing the next logical task."
        
        user_prompt = f"""
### PROJECT CONTEXT
{context_str}
### YOUR DIRECTIVE
1.  **Analyze the entire project context**, especially the full `TASKS.md` file.
2.  **Identify the next single task to work on.** This must be a task with status `-` (Pending) whose dependencies are all marked `+` (Completed). Choose the one with the lowest ID.
3.  **Perform the task.** Create or modify the necessary files to meet its Acceptance Criteria.
4.  **Update the task status.** In your changes to `TASKS.md`, change the status of the task you chose from `-` to `~`.

### INSTRUCTIONS
-   Your response MUST be a single Markdown block containing the file changes.
-   For each file you modify (including `TASKS.md`), use a code block with the full file path, e.g., ```[path/to/TASKS.md]
-   If you determine there are no eligible tasks to work on, respond with only the text "HALT: No eligible tasks found."

Now, determine the next task, generate the necessary file changes, and update `TASKS.md`.
"""
        return [{"role": "system", "content": system_prompt}, {"role": "user", "content": user_prompt}]

    def _make_api_call(self, model: str, messages: list) -> str:
        print(f"Sending prompt to model '{model}' via LiteLLM...")
        try:
            response = litellm.completion(model=model, messages=messages, timeout=300)
            
            # ** THE DEFINITIVE FIX **
            # We must access the first item in the choices list `[0]`
            if response.choices and response.choices[0].message:
                return response.choices[0].message.content or ""
            return ""
            # ** END OF FIX **

        except Exception as e:
            print(f"Error: API call via LiteLLM failed: {e}", file=sys.stderr)
            print("Please check your model name, API keys in .env, and ensure the provider (e.g., Ollama) is running.", file=sys.stderr)
            sys.exit(1)

    def _parse_response(self, response: str) -> dict:
        # (This method is unchanged)
        print("\n--- LLM Response Received ---\n")
        print(response)
        file_changes = {}
        file_pattern = re.compile(r"```\[(.*?)\]\n(.*?)\n```", re.DOTALL)
        for match in file_pattern.finditer(response):
            file_path = match.group(1).strip()
            content = match.group(2)
            file_changes[file_path] = content
        return file_changes

class Agent:
    # (The rest of the Agent class is unchanged)
    def __init__(self, model: str):
        self.model = model
        self.git_manager = GitManager(repo_url=self._get_repo_url())
        self.engine = UnifiedEngine()
        print(f"Agent initialized. Model: {self.model}")

    def _get_repo_url(self):
        try:
            result = subprocess.run(
                ["git", "config", "--get", "remote.origin.url"],
                check=True, capture_output=True, text=True
            )
            url = result.stdout.strip()
            if url.startswith("git@"): url = url.replace(":", "/").replace("git@", "https://")
            return url + ".git" if not url.endswith(".git") else url
        except subprocess.CalledProcessError:
            print("Error: Could not determine git remote URL.", file=sys.stderr)
            sys.exit(1)

    def run_single_task(self):
        print(f"--- Starting Agent in single task mode ---")
        context = self._gather_context()
        file_changes = self.engine.determine_and_execute_next_action(self.model, context)

        if not file_changes:
            print("Agent halted. The LLM did not return any file changes.")
            return

        task_id = self._infer_task_id(file_changes.get("TASKS.md", ""))
        
        branch_name = f"agent/{self.model.replace('/', '-')}/task-{task_id}"
        commit_message = f"feat(agent): Work on Task {task_id}"
        pr_body = f"This PR was automatically generated by the agent ({self.model} model) to work on Task #{task_id}."

        if not self.git_manager.setup_repository(branch_name=branch_name): return
        self._apply_changes(self.git_manager.repo_path, file_changes)
        if not self.git_manager.commit_and_push(commit_message=commit_message): return
        if not self.git_manager.create_pull_request(title=commit_message, body=pr_body): return
        
        print(f"\n--- Agent finished successfully! PR created for Task {task_id}. ---")

    def _gather_context(self):
        files = ["SPEC.md", "SPECIFICATION_GUIDE.md", "TASK_FORMAT.md", "TASKS.md", "AGENT_PRINCIPLES.md"]
        context = {}
        for filename in files:
            try:
                with open(filename, "r") as f: context[filename] = f.read()
            except FileNotFoundError: print(f"Warning: Context file not found: {filename}")
        return context

    def _apply_changes(self, repo_path, changes):
        print("\n--- Applying Changes ---")
        for file_path, content in changes.items():
            full_path = os.path.join(repo_path, file_path)
            os.makedirs(os.path.dirname(full_path), exist_ok=True)
            with open(full_path, "w") as f: f.write(content)
            print(f"Applied change to: {full_path}")

    def _infer_task_id(self, tasks_md_content: str) -> str:
        match = re.search(r'(\d+)\)\s+~\s+.*', tasks_md_content)
        if match:
            return match.group(1)
        return "unknown"

if __name__ == "__main__":
    load_dotenv()
    parser = argparse.ArgumentParser(description="Autonomous AI Agent for Specification Programming.")
    parser.add_argument('--model', type=str, default='ollama/llama3',
                        help="The model string via LiteLLM (e.g., 'ollama/llama3'). (Default: ollama/llama3)")
    args = parser.parse_args()
    
    agent = Agent(model=args.model)
    agent.run_single_task()